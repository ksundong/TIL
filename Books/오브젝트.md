# 오브젝트

![책 사진](https://wikibook.co.kr/images/cover/l/9791158391409.jpg)

1. [객체, 설계](#객체,-설계)
2. [객체지향 프로그래밍](#객체지향-프로그래밍)
3. [역할, 책임, 협력](#역할,-책임,-협력)
4. [설계 품질과 트레이드 오프](#설계-품질과-트레이드-오프)
5. [책임 할당하기](#책임-할당하기)
6. [메시지와 인터페이스](#메시지와-인터페이스)
7. [객체 분해](#객체-분해)
8. [의존성 관리하기](#의존성-관리하기)
9. [유연한 설계](#유연한-설계)
10. [상속과 코드 재사용](#상속과-코드-재사용)
11. [합성과 유연한 설계](#합성과-유연한-설계)
12. [다형성](#다형성)
13. [서브클래싱과 서브타이핑](#서브클래싱과-서브타이핑)
14. [일관성 있는 협력](#일관성-있는-협력)
15. [디자인 패턴과 프레임워크](#디자인-패턴과-프레임워크)
16. [부록 A-계약에 의한 설계](#부록-A-계약에-의한-설계)
17. [부록 B-타입 계층의 구현](#부록-B-타입-계층의-구현)
18. [부록 C-동적인 협력, 정적인 코드](#부록-C-동적인-협력,-정적인-코드)

> 객체지향으로 향하는 첫걸음은 클래스가 아니라 객체를 바라보는 것에서부터 시작합니다. 객체지향으로 향하는 두 번째 걸음은 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 존재로 바라보는 것입니다. 세 번째 걸음을 내디딜 수 있는지 여부는 협력에 참여하는 객체들에게 얼마나 적절한 역할과 책임을 부여할 수 있느냐에 달려 있습니다. 객체지향의 마지막 걸음은 앞에서 설명한 개념들을 여러분이 사용하는 프로그래밍 언어라는 틀에 흐트러짐 없이 담아낼 수 이쓴ㄴ 기술을 익히는 것입니다.
>
> ☞ 객체지향의 사실과 오해, 서문 - 조영호

이 책을 읽고 나면 객체에게 적절한 역할과 책임을 부여하는 방법과 유연하면서도 요구사항에 적절한 협력을 설계하는 방법을 알게 될 것입니다. 나아가 프로그래밍 언어라는 도구를 이용해 객체지향의 개념과 원칙들을 오롯이 표현할 수 있는 방법을 익힐 수 있을 것입니다.

한 가지 염두에 둬야 할 점은 이 책에서 제시하는 방법이 객체지향을 구현하기 위한 유일한 방법은 아니라는 점입니다. 객체지향 애플리케이션을 설계할 수 있는 다양한 접근방법이 있으며 이 책은 그중에서 제가 오랜 시간 실무에 적용하고 실험하면서 유용하다고 생각하는 기법과 원칙들을 하나의 얼개로 통합한 것일 뿐입니다.

## 들어가며

### 패러다임의 시대

패러다임(paradigm)이라는 말은 '모델(model)', '패턴(pattern)', 또는 '전형적인 예(example)'를 의미하는 그리스어인 '파라데이그마(paradeigma)'에서 유래했다. 과거에는 표준적인 모델을 따르거나 모방하는 상황을 가리키는 매우 제한적인 상황에서만 패러다임이라는 단어를 사용했다.

현대인들은 패러다임이라는 단어를 전혀 다른 의미로 사용한다. 우리가 사용하는 패러다임은 '한 시대의 사회 전체가 공유하는 이론이나 방법, 문제의식 등의 체계'를 의미한다.

이렇게 바뀐 이유는 토마스 쿤의 과학혁명의 구조라는 한 권의 책 때문임.

### 프로그래밍 패러다임

프로그래밍 패러다임은 특정 시대의 어느 성숙한 개발자 공동체에 의해 수용된 프로그래밍 방법과 문제 해결 방법, 프로그래밍 스타일이라고 할 수 있다. 간단히 말해서 우리가 어떤 프로그래밍 패러다임을 사용하느냐에 따라 우리가 해결할 문제를 바라보는 방식과 프로그램을 작성하는 방법이 달라진다.

프로그래밍 패러다임이 중요한 이유는 무엇일까?  
 프로그래밍 패러다임은 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유할 수 있게 함으로써 불필요한 부분에 대한 의견 충돌을 방지한다. 또한 프로그래밍 패러다임을 교육시킴으로써 동일한 규칙과 방법을 공유하는 개발자로 성장할 수 있도록 준비시킬 수 있다.

플로이드가 언급한 것처럼 각 프로그래밍 언어가 제공하는 특징과 프로그래밍 스타일은 해당 언어가 채택하는 프로그래밍 패러다임에 따라 달라진다. 각 패러다임과 패러다임을 채용하는 언어는 특정한 종류의 문제를 해결하는 데 필요한 일련의 개념들을 지원한다.

하나 이상의 패러다임을 수용하는 언어를 다중패러다임 언어(Multiparadigm Language)라고 부른다.

'은총알은 없다'는 프레디 브룩스의 말을 기억하라, 객체지향 패러다임은 은총알이 아니다. 객체지향이 적합하지 않은 상황에서는 언제라도 다른 패러다임을 적용할 수 있는 시야를 기르고 지식을 갈고 닦아야 한다.

## 객체, 설계

> 이론이 먼저일까, 실무가 먼저일까?
>
> ☞ 소프트웨어 크리에이티비티 2.0, 이론 대 실무 - 로버트 L. 글래스

대부분의 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각한다. 글래스는 그 반대라고 주장한다. 글래스에 따르면 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 한다. 실무가 어느 정도 발전하고 난 다음에야 비로소 실무의 실용성을 입증할 수 있는 이론이 서서히 그 모습을 갖춰가기 시작하고, 해당 분야가 충분히 성숙해지는 시점에 이르러서야 이론이 실무를 추월하게 된다는 것이다.

저자의 생각은 소프트웨어 분야는 다른 공학 분야에 비해서 역사가 짧기 때문에 이론보다 실무가 더 앞서 있으며 실무가 더 중요하다고 하심.

소프트웨어 설계분야에서 실무는 이론을 압도한다. 설계에 관해 설명할 때 가장 유용한 도구는 '코드' 그 자체다.

### 티켓 판매 애플리케이션 구현하기

조건, 1. 이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다.

2. 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환한 후에 입장 가능하다.
3. 이벤트에 당첨되지 않은 관람객은 티켓을 구매해야만 입장할 수 있다.  
   따라서 관람객을 입장시키기전 1) 이벤트 당첨 여부를 확인해야하고 2) 이벤트 당첨자가 아닌 경우에는 티켓을 판매한 후에 입장시켜야 한다.

초대장 구현

```java
public class Invitation {
  private LocalDateTime when; // 초대일자
}
```

티켓 구현(입장하는 모든 사람이 소유해야 한다.)

```java
public class Ticket {
  private Long fee;

  public Long getFee() {
    return fee;
  }
}
```

관람객(티켓으로 교환할 초대장<이벤트 당첨자>, 티켓을 구매할 현금<당첨되지 않은 사람>)  
소지품을 보관할 용도로 가방을 들고 올 수 있다.

가방 구현

```java
public class Bag {
  private Long amount;
  private Invitation invitation;
  private Ticket ticket;

  public boolean hasInvitation() {
    return invitation != null;
  }

  public boolean hasTicket() {
    return ticket != null;
  }

  public void setTicket(Ticket Ticket) {
    this.ticket = ticket;
  }

  public void minusAmount(Long amount) {
    this.amount -= amount;
  }

  public void plusAmount(Long amount) {
    this.amount += amount;
  }
}
```

이벤트에 당첨된 관람객의 가방에는 현금과 초대장이 들어있지만, 당첨되지 않은 사람은 초대장이 들어있지 않을 것이다. 따라서 인스턴스 생성시점에 이 제약을 강제하도록 생성자를 추가한다. 1) 현금과 초대장을 함께 보관 2) 초대장 없이 현금만 보관

```java
public class Bag {
  public Bag(long amount) {
    this(null, amount);
  }

  public Bag(Invitation invitation, long amount) {
    this.invitation = invitation;
    this.amount = amount;
  }
}
```

관람객 구현

```java
public class Audience {
  private Bag bag;

  public Audience(Bag bag) {
    this.bag = bag;
  }

  public Bag getBag() {
    return bag;
  }
}
```

매표소에선 판매할 티켓과 티켓의 판매금액이 보관되어 있어야 한다.

매표소 구현

```java
public class TicketOffice {
  private Long amount;
  private List<Ticket> tickets = new ArrayList<>();

  public TicketOffice(Long amount, Ticket ... tickets) {
    this.amount = amount;
    this.tickets.addAll(Arrays.asList(tickets));
  }

  public Ticket getTicket() {
    return tickets.remove(0);
  }

  public void minusAmount(Long amount) {
    this.amount -= amount;
  }

  public void plusAmount(Long amount) {
    this.amount += amount;
  }
}
```

판매원은 매표소에서 초대장을 티켓으로 교환해주거나 티켓을 판매하는 역할. 판매원은 자신이 일하는 매표소를 알고 있어야 한다.

_왜 매표소가 판매원을 가지고 있지 않고 판매원이 매표소를 알고 있도록 했을까?_

판매원 구현

```java
public class TicketSeller {
  private TicketOffice ticketOffice;

  public TicketSeller(TicketOffice ticketOffice) {
    this.ticketOffice = ticketOffice;
  }

  public TicketOffice getTicketOffice() {
    return ticketOffice;
  }
}
```

소극장 구현

```java
public class Theater {
  private TicketSeller ticketSeller;

  public Theater(TicketSeller ticketSeller) {
    this.ticketSeller = ticketSeller;
  }

  public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().setTicket(ticket);
    } else {
      Ticket ticket = ticketSeller.getTicketOffice().getTicket();
      audience.getBag().minusAmount(ticket.getFee());
      ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
      audience.getBag().setTicket(ticket);
    }
  }
}
```

_코드 쓰면서 고치고 싶은점이 한 두개가 아닌데..._

이 작은 프로그램은 몇 가지 문제점을 가지고 있다.

## 객체지향 프로그래밍

## 역할, 책임, 협력

## 설계 품질과 트레이드 오프

## 책임 할당하기

## 메시지와 인터페이스

## 객체 분해

## 의존성 관리하기

## 유연한 설계

## 상속과 코드 재사용

## 합성과 유연한 설계

## 다형성

## 서브클래싱과 서브타이핑

## 일관성 있는 협력

## 디자인 패턴과 프레임워크

## 부록 A-계약에 의한 설계

## 부록 B-타입 계층의 구현

## 부록 C-동적인 협력, 정적인 코드
