# TCP Protocol

## TCP란

Transmission Control Protocol로 컴퓨터 간의 메시지 교환을 용이하도록 하는 연결 지향 통신 프로토콜입니다. 인터넷 프로토콜(IP)을 사용하는 네트워크에서 가장 일반적으로 사용하는 프로토콜로, TCP/IP 라고 둘을 묶어서 부르기도 합니다.

TCP는 애플리케이션/서버에서 메시지를 받아 패킷으로 나눕니다. 이는 스위치, 라우터, 보안 게이트웨이를 통해 네트워크로 보내지고, 목적지로 전달됩니다. TCP는 각 패킷에 순서를 매기고, 이를 애플리케이션/서버 수신자에게 전달되기 전에 재조립합니다. 왜냐하면 TCP는 연결지향이기 때문인데, 메시지를 보내고 받는 애플리케이션/서버간의 메시지 교환이 완료될 때 까지 연결이 설정되고 유지됩니다.

예를 들어, 우리가 `SMTP` 프로토콜을 이용해서 이메일 서버를 통해 이메일을 보낼 때, `TCP` 레이어는 메시지를 여러개의 패킷으로 쪼개서 `IP` 레이어에 전달함을 통해 전송하게 됩니다. `IP` 레이어에서는 각 패킷이 목적지 이메일 서버에 전송됩니다. 각 패킷이 같은 곳으로 향하지만, 패킷들이 거쳐가는 경로는 아마도 다를겁니다. 이것이 도착하면, `IP` 레이어에서는 `TCP` 레이어로 전달하고, `TCP` 레이어는 패킷들을 재조합해 메시지로 만든 다음 이메일 애플리케이션에 전달합니다. 그러면 수신함에 메일이 보이게 됩니다.

또한 TCP의 연결은 전이중(full-duplex) 입니다. 전이중의 의미는 양방향 통신이 가능하다는 의미입니다. 또 TCP는 점대점(point-to-point) 통신입니다. 점대점 통신은 송신자와 수신자와 단 둘만 존재하는 통신이라는 의미입니다.

[출처](https://www.sdxcentral.com/resources/glossary/transmission-control-protocol-tcp/)

## 왜 TCP를 사용하는가?

TCP 프로토콜은 프로토콜 차원에서 연결을 지향하기 때문에 애플리케이션에서는 이를 믿고 개발할 수 있다는 장점이 있습니다. 그 말은 우리가 사용하는 애플리케이션 중 연결 안정성이 중요한 경우에도 굳이 애플리케이션 개발자가 데이터가 안전하게 전송되는지는 신경쓰지 않아도 된다는 의미입니다. 당연히 좀 더 원하는 목적에 집중할 수 있게됩니다.

### TCP는 어떻게 연결 안정성을 보장하는가?

TCP는 오류 감지, 재전송, 누적 확인응답, 타이머, 시퀀스(SEQ)와 애크(ACK) 넘버를 위한 헤더 필드를 통해 보장합니다.

출처: Computer Networking A Top Down Approach p.261

## TCP는 어디에 사용하는가?

같은 Transport Layer Protocol인 UDP와 TCP의 차이점을 알고, TCP의 통신 과정에 대한 이해가 있다면, 어느 곳에 TCP 프로토콜을 사용하는지 알 수 있습니다.

우리가 사용하는 웹, 메일, 파일 공유 등의 애플리케이션은 연결 안정성이 중요하기 때문에 TCP를 사용합니다.

## TCP가 하는 일

TCP는 네트워크를 통해서 효율적으로 데이터를 라우팅 할 수 있도록 데이터를 분할하고 조립하는 역할을 합니다. 이 단위를 'segment' 라고 하고, 이를 우리는 보통 패킷이라고 합니다.

네트워크는 예측할 수 없기 때문에 우리가 순서대로 전송한 데이터라도 패킷이 손실되거나, 순서가 엉망으로 전달될 수 있습니다. TCP는 패킷 데이터의 순서를 조정하거나, 재전송을 요청하여 이러한 문제를 감지할 수 있고, 최소화할 수 있습니다. 이러한 정확도 때문에 TCP의 속도는 느려지게 됩니다. 따라서 정확도와 속도의 트레이드 오프 관계라고 볼 수 있습니다.

## TCP의 통신 과정

TCP를 얘기하면 빼놓을 수 없는 것이 hand shake입니다. 특히 3way handshake는 굉장히 자주 출제되는 면접문제기도 합니다.

### three-way handshake

TCP three-way handshake 과정은 다음과 같습니다.

![1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled.png](1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled.png)

[이미지 출처](https://www.mdpi.com/2076-3417/6/11/358/htm)

이 three-way handshake 과정은 결국 TCP의 연결을 확립하기 위한 과정입니다.

1. 클라이언트 측 TCP는 서버 TCP에게 특별한 세그먼트를 보내는데 여기에는 애플리케이션 계층 데이터를 포함하지 않습니다. 그러나 헤더에 SYN 플래그 비트와 순서번호 필드에 랜덤한 번호(client_isn)를 넣어서(보안 공격을 피하기 위해) 전송합니다. 
2. 서버측 TCP는 TCP SYN 세그먼트를 뽑아냅니다. 그리고 연결 승인 세그먼트를 보냅니다.
   SYN 비트는 1로 설정되며, TCP 확인 응답 필드는 client_isn + 1이 됩니다. 순서 번호 필드는 (server_isn)으로 설정됩니다.
   이를 SYNACK라고 부릅니다.
3. 클라이언트측 TCP는 SYNACK 세그먼트를 받아 또 다른 세그먼트를 송신합니다.
   연결이 설정되었기 때문에 SYN 비트는 0, 순서 번호에 client_isn + 1, 확인 응답 필드에 server_isn + 1으로 보냅니다.

이렇게 하면 연결이 설정되어 각각 서로에게 애플리케이션 데이터를 포함하는 세그먼트를 보낼 수 있습니다.

### four-way handshake

TCP 연결을 할 때, 스트림을 할당해주기 때문에 이를 할당 해제하는 방법도 필요합니다.

이 때 쓰는것이 바로 four-way handshake입니다.

![1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%201.png](1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%201.png)

[이미지 출처](https://www.geeksforgeeks.org/tcp-connection-termination/)

1. 클라이언트는 FIN 비트를 1로 설정하고 서버에 요청합니다. 클라이언트의 상태는 FIN_WAIT_1 이 됩니다.
2. 서버는 FIN 비트 세그먼트를 받고, 서버는 즉시 ACK 세그먼트를 보냅니다.
3. 클라이언트가 ACK 세그먼트를 받으면 FIN_WAIT_2 상태가 되고, 서버로부터 오는 FIN 세그먼트를 기다리게 됩니다.
4. 서버는 FIN 비트 세그먼트를 클라이언트에 보냅니다. 그리고 ACK 세그먼트를 기다립니다.
5. 클라이언트가 FIN 비트 세그먼트를 받으면 TIME_WAIT 상태가 됩니다. 그리고 ACK 세그먼트를 서버에 보내고 계속해서 기다립니다. 그 이유는 혹시나 서버측에서 전송되는 처리되지 않은 정보가 뒤늦게 올 수 있기 때문입니다. 이는 TCP 구현에 따라 다르며, 대체로 30초, 1분, 2분 정도입니다. 대기 후에는 연결이 완저히 종료되고, 클라이언트 측의 모든 리소스가 해제됩니다.

### TCP 상태 전이

위에서 설명한 내용을 각 상태별로 구분하면 다음과 같습니다.

#### 클라이언트 측

![1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%202.png](1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%202.png)

#### 서버 측

![1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%203.png](1%20TCP%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%8F%E1%85%A9%E1%86%AF%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%A2%E1%84%82%E1%85%A7%E1%86%B7%E1%84%80%E1%85%AA%20%E1%84%90%E1%85%B3%E1%86%A8%E1%84%8C%E1%85%B5%E1%86%BC%207cdb57d91d334471961091efac8cc159/Untitled%203.png)

## TCP 혼잡제어

TCP는 네트워크 혼잡에 따라 커넥션에 트래픽을 보내는 전송률을 각 송신자가 제한하도록 하여 혼잡을 제어합니다.

만약, TCP 송신자가 자신과 목적지 간의 경로에서 혼잡이 없음을 감지하면 송신자는 송신율을 높입니다. 반면 송신자가 경로 사이에 혼잡을 감지하면 송신자는 송신율을 줄입니다.

그렇다면 어떻게 TCP 송신자는 자신의 연결에 전송률을 제한하며, 어떻게 혼잡을 감지하며, 혼잡을 감지함에 따라 송신율을 변화시키기 위해서 어떤 알고리즘을 사용해야 할까요?

이 부분은 너무 깊다고 느껴지는 부분이 있어서 전공 서적을 참고하시면 좋을 것 같습니다.
