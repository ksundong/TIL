# 2020-03-10-TIL

## 오늘 할 일

- [x] 알고리즘 공부하기
- [x] 운동하기
- [ ] STEP6 개선하기
- [x] 회고하기
- [ ] 포비 강의 듣기

늦잠을 자버렸다...

## 알고리즘 공부

### 이진탐색(Binary Search) 보충

```java
class BinarySearch() {
    public int search(int[] arr, int target) {
        int firstIndex = 0;
        int lastIndex = arr.length - 1;
        
        while (firstIndex < lastIndex) {
            int middleIndex = (firstIndex + lastIndex) / 2;
            int middleValue = arr[middleIndex];
            
            if (target == middleValue) {
                return middleIndex;
            } else if (target < middleValue) {
                lastIndex = middleIndex - 1;
            } else {
                firstIndex = middleIndex + 1;
            }
        }
        
        return -1;
    }
}
```

재귀 없이도 이진 탐색이 가능합니다.

아이디어는 재귀와 동일합니다.

### 빅 오 표기법(Big-O Notation)

[참고: 칸 아카데미 알고리즘 > 점근적 표기법](https://ko.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation)

#### 표기법이란?

대개의 경우 알고리즘의 실행 시간은 컴퓨터가 알고리즘을 실행하는 속도에 의존합니다.

이 속도는 컴퓨터의 처리속도, 사용된 언어 종류, 프로그래밍 언어를 컴퓨터가 실행할 수 있는 코드로 바꾸는 컴파일러의 속도 등에 달려있습니다.

하지만 우리는 **이 시간을 대략적으로 추측할 수 있는 방법**이 필요합니다. 그래서 표기법이 등장했습니다.

---

그럼 이 표기법은 어떻게 계산할까요? 수학적으로 생각한다면, 요소가 n이 증가하면 그에 비례해서 시간이 일정하게 증가하는 경우  n만큼 걸린다고 볼 수 있을 것입니다. 그리고, 2배로 비례해서 증가한다면 2n이 되겠죠. 또, 제곱으로 비례해서 증가한다면 n<sup>2</sup> 이라고 볼 수 있습니다.

이렇게 입력값의 크기에 따라 알고리즘이 얼마나 실행속도가 증가하는지 알아보는 것을 실행 시간의 **성장률(rate of growth)**이라고 부릅니다. **6n<sup>2</sup>+100n+300** 이라는 성장률에 대한 함수가 있을 때, 우리는 이를 간소화해서 보는 편이 더 좋을 것입니다. 실제로 n이 증가함에 따라 6n<sup>2</sup>에 비해서 100n+300의 비중은 그리 크지 않게됩니다.

---

따라서 우리는 약속을 합니다. 계수인 6, 그리고 나머지 항목인 100n+300을 제외하고 실질적으로 알고리즘의 실행속도에 가장 큰 영향을 미치는 부분인 n<sup>2</sup>만으로도 충분하다는 것이죠.

이렇게 중요하지 않은 항과, 상수 계수를 제거하면 알고리즘을 이해하는데 방해되는 불필요한 부분을 생각하지 않을 수 있어서 알고리즘에서 중요한 부분인 성쟝률에 집중할 수 있습니다.

이렇게 중요하지 않은 항과, 상수 계수를 제거한 표기법을 **점근적 표기법(asymptotic notation)**이라고 합니다.

#### 왜 표기법을 사용할까?

표기법을 사용하는 이유는 **알고리즘의 효율성을 나타내는 지표이기 때문입니다.**

또, 다른 개발자와 알고리즘에 대하여 얘기할 때, **표기법을 이용하여 소통하는 편**이 더 원할하기 때문입니다.

#### 빅 오 표기법이란?

알고리즘을 실행하였을 때, 최악의 경우를 의미합니다. 가장 보편적으로 사용하는 표기법입니다. 한계를 위에다만 두는 것이지요.

이를 시간(또는 공간)의 상한선이라고도 합니다.

정확한 뉘앙스는 "실행 시간은 최대한 이만큼 커지지만 더 천천히 커질 수도 있다." 라는 의미입니다.

쉽게 설명하면, "제일 오래걸리면 이 정도 걸릴 것이다." 라는 의미라고도 볼 수 있습니다.

이는 대개의 알고리즘은 시간에 대해서 얘기하는 경향이 있기 때문입니다. (항상 알고리즘은 시간과 공간의 적절한 조화가 중요합니다.)

#### 다른 표기법에는 무엇이 있을까요?

- 빅 오메가 표기법
  - 가장 최선의 경우를 의미합니다.
- 빅 세타 표기법
  - 평균적인 상황의 경우를 의미합니다. 빅 오와 빅 오메가의 공통부분입니다. 세타 표기법으로 표기할 수 없는 경우도 존재합니다.
- 이를 제외한 나머지 표기법들도 존재하나, 거의 쓰이지 않습니다.

#### 왜 빅 오 표기법이 다른 표기법 보다 많이 쓰일까요?

대부분의 경우 우리의 관심이 가장 최악의 경우에 어떻게 될 것인지에 쏠려있기 때문입니다.

아무리 linear search가 최선의 경우 1의 속도를 가진다고 해도, 최악의 경우 n의 속도가 걸리기 때문에 사용하지 않는 것과 같은 이유라고 보면 될 것 같습니다.

## JPA 으아아

[jpa 엔터티 카운트 성능 개선하기](https://www.popit.kr/jpa-%EC%97%94%ED%84%B0%ED%8B%B0-%EC%B9%B4%EC%9A%B4%ED%8A%B8-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0%ED%95%98%EA%B8%B0/)

`@OneToMany`의 경우 fetch Type이 Lazy 이기 때문에 사용하지 않으면 쿼리를 하지 않는다.

하지만, Count를 구하기 위해 `.size()`를 사용할 경우 쿼리가 SELECT COUNT가 아니라 SELECT 쿼리가 전송되면서 비용이 엄청 증가하게 된다. 주의하자.

[jpa 변경 감지와 스프링 데이터](https://medium.com/@SlackBeck/jpa-%EB%B3%80%EA%B2%BD-%EA%B0%90%EC%A7%80%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-2e01ad594b82)

JPA가 `.save()`를 할 때, 직접적으로 넣어준 객체만이 아니라 연관된 `Entity`들을 모두 `update`를 해주길래 여러 추측을 해보았고, 그에 대한 답을 Solar가 찾아주셨다. 어느정도 예상했던 것과 일치하는 것 같다.

## 배열과 리스트의 차이

자바에서는 `Array, ArrayList, LinkedList`로 구분할 수 있습니다.

대부분의 경우 알고리즘 문제에서는 Array를 주지만, 실제 코딩을 할 때에는 ArrayList를 사용하는 것이 개발할 때 더 편합니다.

Array와 ArrayList는 모든 특성이 같지만, Array는 크기조절을 직접해줘야 하기 때문입니다. 속도는 빠르지만, 불편하기 때문에 잘 사용하지 않습니다.

따라서 세 경우를 전부 비교하지 않고 `ArrayList`와 `LinkedList`만 비교하려고 합니다.

### Java Array와 ArrayList의 차이

**Array**와 **ArrayList**은 모든 것이 비슷합니다. 가장 큰 차이점은 길이를 조정할 수 있는가? 없는가? 입니다.

Java의 **Array**는 고정 길이 입니다. 따라서, 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어주어야 합니다.

Java의 **ArrayList**는 가변 길이입니다. 하지만 내부적으론 배열로 구성되어 있습니다. ArrayList는 Default로 10개의 공간을 가진 배열로 시작합니다. 하지만 최적화(지연 초기화)로 인해 막 생성하면 0개의 사이즈로 시작됩니다. [참고](https://stackoverflow.com/questions/34250207/in-java-8-why-is-the-default-capacity-of-arraylist-now-zero) 

> 검색어: ArrayList default size

그 밖에 정해진 용량을 초과하면 새로 배열을 생성할 때에는 JDK의 구현마다 다른 구현방식을 사용할 수 있습니다. [참고](https://stackoverflow.com/questions/4450628/arraylist-how-does-the-size-increase)

> 검색어: arraylist capacity increase in java

즉, ArrayList는 좀 더 개발자에게 편한 배열이라고 생각할 수 있습니다. 다만, 편리함의 대가로 살짝 Array보다 느리니 Array로 충분히 처리 가능하다거나 코딩 테스트나 알고리즘을 풀 때에는 Array를 활용해주는 것이 좋을 것 같습니다.

### ArrayList와 LinkedList의 차이

#### 공간적 제약

`ArrayList`는 결국 배열이므로 길이가 고정되어 있습니다. 때문에, 새로 배열에 새로운 요소를 추가하려고 할 때, 배열의 용량이 이미 가득 차있다면 새로운 배열을 생성해주어야 합니다. 이 때, 새로 생성된 배열이 메모리 상에 연속해서 생길 수도 있지만, 이미 다른 값이 메모리를 사용하고 있는 경우, 새로운 위치에 배열이 생성되어야 하고 이는 모든 요소를 옮긴다는 얘기가 됩니다. 또 메모리에 여유공간이 없는 경우 에러가 발생할 수도 있습니다.

반면, `LinkedList`는 한 개의 `Node`는 다른 `Node`에 대한 참조만 가지고 있습니다. 따라서 공간적 제약을 `ArrayList`에 비해 받지 않습니다. 

#### 새로운 요소 추가

`ArrayList`는 새로운 요소를 추가할 때, 여유 공간이 있는 경우엔 `O(1)`이지만, 여유공간이 없는 경우엔 `O(n)`이므로 `O(n)`입니다.

`LinkedList`는 새로운 요소를 추가할 때, 항상 `O(1)`입니다. 왜냐하면, 그냥 마지막 요소에서 다음 참조값을 가지게만 하면 되기 때문입니다.

#### 임의 접근과 순차 접근

**임의 접근(Random Access)**은 어떤 요소에 바로 접근하는 것을 이야기합니다. 반면 **순차 접근(Sequential Access)**은 어떤 요소에 접근할 때, 차례차례 접근하는 것을 이야기합니다.

대개의 경우 `List`의 구현체로 `ArrayList`를 사용하는 이유가 바로 이 임의 접근에 있습니다. 바로 접근이 가능하다는 것은 곧 `O(1)`을 의미하기 때문입니다. 반면, `LinkedList`의 경우엔 순차 접근만 가능하므로 `O(n)`이 걸리게 됩니다.

#### 새로운 요소 삽입(중간에)

`ArrayList`는 해당 요소뒤의 요소들도 전부 옮겨야 합니다. 하지만, `LinkedList`는 앞 뒤 요소의 값만 바꾸어주면 됩니다.

#### 요소 삭제

요소 삭제의 경우도 삽입의 경우와 유사합니다. 중간의 요소를 삭제할 경우 `ArrayList`는 뒤의 요소들을 전부 앞으로 이동시켜야합니다. 하지만, `LinkedList`의 경우에는 앞 뒤 요소의 값만 바꾸어주면 됩니다.

#### 요약

|      | ArrayList | LinkedList |
| :--: | :-------: | :--------: |
| 접근 |   O(1)    |    O(n)    |
| 추가 |   O(n)    |    O(1)    |
| 삭제 |   O(n)    |    O(1)    |

- 추가와 삭제는 해당 요소의 추가 삭제시에 소요되는 복잡도를 의미합니다.
  그 외의 접근하는 복잡도는 고려하지 않습니다.

## 알고리즘 공부할 때 참고할만한 사이트

- [알고리즘을 눈으로 확인할 수 있는 사이트](https://visualgo.net/en)
- [빅오표기법을 확인할 수 있는 사이트](https://www.bigocheatsheet.com/)

## 오늘의 회고

- 잘한 점
  - 늦잠을 자도 지각을 하진 않았다.
  - 깃헙 버그리포트가 정상적으로 접수되었다.
  - 다른 분들에게 도움이 되어드렸다.
  - 운동을 꾸준히 하고 있다.
- 못한 점
  - 목표로 하고자 한 것을 제대로 하지 못했다.
  - 자다 깨서 핸드폰을 한 시간을 해버려서 늦잠잔 것 같다.
- 보완점
  - 자다 깨면 그냥 다시 자자!

## 내일 할 일

- [ ] 포비 강의 듣기
- [ ] 알고리즘 공부하기
- [ ] 운동하기
- [ ] 회고하기

