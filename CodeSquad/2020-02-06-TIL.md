# 2020-02-06-TIL

## 코드스쿼드 쪽지 시험

```
변수의 스코프
접근 한정자
객체 지향 프로그래밍
클래스와 인스턴스
상속
추상 클래스
인터페이스
메소드 오버로딩과 오버라이딩
열거형의 사용법
예외 처리
컬렉션 프레임워크
내부 클래스, 중첩 클래스와 람다
스트림
Optional
IO 스트림
```

### 변수의 스코프

- ~~전역 변수~~(클래스 변수): 클래스 전체가 공유하는 변수, 클래스가 메모리에 올라갈 때 생성됨
- 인스턴스 변수(멤버 변수): 인스턴스 내부에서 공유되는 변수, 인스턴스가 생성되었을 때 생성됨
- 스코프 변수(로컬 변수): 해당 스코프 내에서만 사용되는 변수, 변수 선언문이 수행되었을 때 생성됨

### 접근 한정자

- private: 자기 인스턴스 내부에서만 접근 가능
- protected: default에 더해서 상속 받는 인스턴스에서도 접근 가능
- default: 같은 package에 있는 클래스의 인스턴스에서 접근 가능
- public: 모두 접근 가능

### 객체 지향 프로그래밍

- 프로그램의 소스코드의 복잡도를 낮추기 위한 기법
- 현실 세계의 일부를 가져와 만든 기법(현실하고 일치할 필요가 없음)
- 프로그램은 객체의 협력, 상호작용 등으로 실행됨
- 공통된 부분을 추출하여 부모 클래스를 만들거나 인터페이스를 만드는 등으로 코드의 재사용성을 높임.

### 클래스와 인스턴스

- 클래스는 인스턴스의 설계도, 클래스는 객체를 생성하는데 사용됨.
- 인스턴스는 클래스에 정의된 대로 메모리에 생성된 것. 즉 객체지향에서 객체라고 볼 수 있는 상호작용의 주체임

### 상속

- 상위(부모)클래스의 확장
- 상위(부모)클래스의 기능을 구현하며, 거기에 추가적으로 기능을 제공할 수 있도록 함
- 코드의 재사용성을 높이기 위한 기법 중 하나
- 상속은 단 하나의 클래스로 제한됨.
  - 왜 다중상속을 지원하지 않을까..?

### 추상 클래스

- 미리 행동이 정의되어 있지만, 그 자체 만으로는 인스턴스를 만들 수 없는 클래스
- 코드의 재사용성을 높이기 위한 기법 중 하나
- 추상 메소드를 가질 수 있음.
- Swift의 프로토콜과 유사하다고 생각됨.(프로토콜은 추상 클래스, 인터페이스의 성격을 모두 가지고 있음)
- 추상 클래스도 클래스이므로 상속을 통해서 구현해야 함.

### 인터페이스

- 클래스를 어떻게 사용할 수 있는지 알려주는 것
- 이면서, 클래스를 어떻게 설계해야 한다고 지정하는 설계도
- 인터페이스는 그 자체만으로는 사용이 불가능하므로, 구현을 해주어야 함.
- java에서는 인터페이스를 다중으로 구현할 수 있음.
- 인터페이스 구현체는 무조건 선언된 메소드를 Override 해야함. 이러한 이유 때문에 위의 두 가지 조건이 성립됨.
- 인터페이스 간에도 extends 선언이 가능함.

### 메소드 오버로딩과 오버라이딩

- 오버로딩: 하나의 메소드가 여러 가지 매개변수를 받을 수 있도록 해주는 것. 대표적으로, Junit의 assert method들이 overloading으로 구성되어 있음.
- 오버라이딩: 상속을 받은 경우 부모 클래스의 메소드를 재정의 한다는 의미, 인터페이스를 구현을 하는 경우 메소드를 구현한다는 의미.

### 열거형의 사용법

- Enumeration은 공통된 상태를 가지는 상수들을 하나의 묶음으로 만드는 것.
- 예를 들어 요일의 경우 WeekOfDays라는 Enum을 만들어 줄 수 있음.
- switch case문이나 상태를 나타내는 코드에서 사용하면 코드 가독성이 높아짐.
- 또한, 같은 의미지만 표현하는 값이 다를 경우 생성자를 지정해주어서 여러 코드에서 다양한 방법으로도 표현할 수 있음.

### 예외 처리

- 프로그램 실행 도중 의도치 않은 동작이 발생했을 때, 이를 처리하기 위한 방법
- 무조건 예외는 처리해주어야 한다. (예외가 main method에서도 catch 되지 않았을 경우 프로그램이 비정상 종료됨.)
- 해당 method에서 Exception을 throw하여 호출한 메소드에서 처리하는 방법이 있다.
- try, catch 문으로 try문 실행도중 Exception이 발생했을 때, catch 블록에서 지정한 Exception일 경우 catch블록에서 해당 에러를 처리해 줄 수 있고, catch 문은 이어서 쓸 수도 있다.

### 컬렉션 프레임워크

- Java에서 지원하는 자료구조를 구현한 코드들의 모음
- Iterable의 구현체로 이루어져있음.
- List, Set, Map, Tree 등의 인터페이스를 제공하며, 이들의 구현체 또한 제공함.
- Vector, Queue, Deque 등도 지원함

### 내부 클래스, 중첩 클래스와 람다

- 내부 클래스: 클래스 내부에 클래스를 선언해주는 것. (자주 사용되는 형태는 아니라고 생각함.)

- 내부 클래스는 이를 포함하는 클래스외에서도 사용 가능함

- 내부 클래스는 static 선언을 해줄 수 없음

- 한 번 짜보기

  ```java
  public class Test {
      public static void main(String[] args) {
          Test test = new Test();
          Hell hell = test.new Hell();
          Hell.Wow wow = hell.new Wow();
          hell.hell();
          wow.hello();
      }
      private class Hell {
          void hell() {
              System.out.println("what the hell");
          }
          class Wow {
              void hello() {
                  System.out.println("hello");
              }
          }
      }
  }
  ```

- 위에서 보다시피 상위 객체가 생성되어야만 사용 가능함.

- ❓왜 제공할까?

- 중첩 클래스: 내부 클래스, 지역 클래스, 익명클래스, 정적 중첩클래스를 부르는 것

- 람다: 자바 8부터 추가된 것으로 Java에서도 함수형 프로그래밍을 할 수 있게 되었음.

### 스트림

- Java에서 고차함수를 효과적으로 지원하기 위한 프레임워크
- 주로 연속된 형태를 가진 배열이나, Collection 인터페이스를 구현하는 클래스에서 .stream()으로 stream을 사용할 수 있음.

### Optional

- Optional으로 선언한 것은 null값 처리를 해줄 수 있다.

- 한 번 짜보기

  ```java
  public class Test {
      public static void main(String[] args) {
          Optional<Integer> integer = Optional.empty();
          System.out.println(integer.isPresent());
          integer = Optional.of(3); // null 넣으면 NullPointerException 발생함.
          System.out.println(integer.isPresent());
          integer = Optional.ofNullable(null);
          System.out.println(integer.isPresent());
      }
  }
  ```

- Swift에서 null 처리를 optional이라는 것으로 한다고 들었는데 같은걸까?

### IO 스트림

- Input, Output은 한 번 전달되면 끝나는 것이 아니라, 계속해서 들어와야 하므로, 이를 stream이라고 함.
- 이는 운영체제에서 할당받아 사용하므로, 사용이 끝난 후 반납을 해주어야 함.(닫아주어야 함.)

## 코드스쿼드 강의

- 객체지향은 객체의 능력의 유무가 더 중요하다. 종으로 묶는것은 좀 별로다.
- 멤버변수(클래스 변수, 인스턴스 변수), 로컬변수

- Scope 메모리 구조 -> JVM - 고급 개발자들은 bytecode도 읽을 수 있다,
- GC의 동작원리를 알아야 한다.
  왜할까요? 자원을 아끼기 위해서
  왜 아껴야할까요?
- StringBuilder, StringBuffer를 사용하는 이유 String이 Immutable객체이기 때문에 GC가 동작해서 성능저하가 발생하기 때문입니다.
- 함수형은 Immutable하기 때문에 성능상 단점이 생긴다. (가독성이 좋아질 때만 사용한다.)
- static 변수는 모든 인스턴스가 공유하는 변수
- 접근 한정자 기본은 private이다. for encapsulation
- 클라우드 - 최소 권한 부여의 원칙
- 리눅스 커널은 C언어로 되어있음
- 왜 객체지향을 사용하는가? 유지보수, 가독성
- 추상 클래스 (인스턴스 생성 불가, 추상 메소드를 포함할 수 있음)
- IoC, DI 공부하기
- Enum을 사용하는 이유: 유지보수를 하기 쉽게 하기위해, 변수를 상수처럼 사용
  열거형은 보통 제한된 값에 사용하지, 너무 넓은 범위에 사용하지 않는다.
- 적절한 예외 처리를 생각하자(사용자는 생각한대로 절대 수행하지 않는다.)
- 컬렉션 프레임워크 (묶음을 처리하기 위한 프레임워크)
- java.lang, java.util, collection framework를 잘 써보자.
- 작은 것 또한 잘하자.

### TDD

- 먼저 실패하는 테스트를 짠다.
- 컴파일은 되지만 오류가 나는 테스트를 짠다.
- 당장 이 테스트만 통과하는 수준으로 코드를 구현한다.
- 테스트와 코드를 다시 리팩토링한다.
- 기능은 그대로 냅두고 코드의 퀄리티를 높이는 작업 리팩토링
- 단위 테스트가 있다. 최소 실행단위인 메소드를 테스트함.
- 통합 테스트, E2E 테스트
- 프로덕션 코드와 테스트 코드의 분리
- 코드는 일종의 글 임. 당연히 읽기 좋아야 한다.
- 모든 단위테스트는 순서가 없어야 한다.
- 테스트는 항상 같은 결과를 반환해야 한다.
- TDD의 장점은 일부를 고쳤을 때, Side Effect를 알아낼 수 있다는 것이다.
- Mock - 자바 Reflection을 이용
- 외부에서 주입받는 것을 고려해보라
- 테스트 때문에 코드를 바꾸는 것도 고려해봐야한다.
- UI(?)[는]() 코드 바깥으로 빼낸다.