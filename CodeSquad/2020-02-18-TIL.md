# 2020-02-18-TIL

## 오늘 할 일

- [ ] STEP1에서 정리해야 할 내용 정리하기
- [ ] 제네릭 공부하기
- [ ] 등운동하기
- [ ] HTTP 공부하기
- [ ] 프로그래머스 1문제 풀기
- [ ] 리뷰받으면 지적사항 수정하기
- [ ] 회고하기

## heroku 배포방법

1. heroku에 가입한다.
2. 각 OS에 따라 설치 방법을 따른다.
   Mac의 경우 `brew install heroku/brew/heroku` 로 간편하게 설치할 수 있다.
3. `heroku login` 을 하면 웹 사이트가 열리는데 인증절차를 거치면 로그인이 된다.
4. project directory로 이동한다.
5. `heroku create` 를 한다. <git remote repository를 생성시킨다.>
   heroku는 `master` 브랜치의 내용만 배포된다.
6. `heroku ps:scale web=1` 로 상태를 확인할 수 있다.
7. `heroku open` 으로 사이트를 열 수 있다.
8. `git push heroku {local branch}:master` 로 푸시하면 local branch가 heroku의 master로 push되므로 개발환경에서도 배포가 가능하다.

## @Controller란?

`@Controller`는 빈 자동인식에 사용되는 스테레오 타입 애노테이션

`@MVC` 의  Controller는 이 애노테이션을 선언해서 만든다.

`@Controller` 에서는 컨트롤러 역할을 담당하는 메소드의 파라미터 개수와 타입, 리턴 타입등을 자유롭게 결정할 수 있다.

물론 사용 가능한 파라미터와, 리턴 값의 종류가 지정되어 있긴 하지만, 이를 어떻게 구성해서 메소드를 설계할 것인지는 개발자의 자유다.

그래서 `@Controller`를 담당하는 어댑터 핸들러는 상당히 복잡하다.

```java
@RequestMapping("/hello")
public void hello() { ... }
```

파라미터도 없고, 리턴 타입도 존재하지 않는 메소드 → /hello 요청이 들어오면 hello 메서드 실행(스프링에서) → 리턴 값이 없는 메소드라면 스프링은 비어 있는 모델 오브젝트와 뷰 이름을 돌려줌(뷰 이름은 hello라고 자동으로 만들어짐)

**HttpServletRequest를 인자로 받는 방식보다는 애노테이션을 사용해서 받는 방식이 더 최신방식임.**

스프링은 메소드의 파라미터와 리턴 값이 어떻게 선언됐는지 살펴보고, 이를 이용해 적절한 파라미터 값을 준비해서 호출해준다. 리턴 값도 타입에 따라 적절한 방식으로 사용한다.

`@Controller`에서 허용되는 파라미터와 리턴 값의 종류를 알고 있다면 필요한 정보만을 주고받을 수 있는 최적화된 메소드를 설계할 수 있다.

## Post 메소드로 전송된 데이터를 처리한 후 redirect 시켜주는 이유

[참고](https://stackoverflow.com/questions/1083357/do-you-always-redirect-after-post-if-yes-how-do-you-manage-it)

[참고2](https://blog.outsider.ne.kr/312)

1. Data를 다시 전송시키지 않기 위해서

## 리뷰된 내용 수정하기

1. honux가 제안한대로 User 자체를 받아오려면 어떻게 해야할지 고민했는데, request를 보내줄 때, name field명이 일치하도록 form을 보내주면 되는 것 같다.

   ```java
   // Before
   @PostMapping("/user/create")
   public String createUser(HttpServletRequest request) {
       String userId = request.getParameter("userId");
       String userPassword = request.getParameter("password");
       String userName = request.getParameter("name");
       String userEmail = request.getParameter("email");
   
       User newUser = new User(userId, userPassword, userName, userEmail);
       users.add(newUser);
       return "redirect:/users";
   }
   // or
   @PostMapping("/user/create")
   public String createUser(@RequestParam String userId,
                            @RequestParam String userPassword,
                            @RequestParam String userName,
                            @RequestParam String userEmail) {
       User newUser = new User(userId, userPassword, userName, userEmail);
       users.add(newUser);
       return "redirect:/users";
   }
   ```

   ```java
   // After
   @PostMapping("/user/create")
   public String createUser(User user) {
       users.add(user);
       return "redirect:/users";
   }
   ```

   honux와 얘기를 해보면서 `@RequestParam`의 동작원리를 조금이나마 이해한 것 같다. `@RequestParam`은 전송된 정보의 name중에 해당 매개변수명으로 되어있는 이름을 찾아서 연결시켜 주는 것 같다. 따라서 `@RequestParam User user` 는 동작하지 않는다.

   또한 `@RequestParam`의 `required` 속성의 default 값은 true인데, 이는 필수적이어서 누락되었을 경우 error를 출력해준다고 한다. 반면 적지 않았을 경우엔 `required`가 false여서 누락되어도 error를 출력하지는 않는다.

2. 여러 시간대를 한꺼번에 대응할 필요가 없다면 `ZonedDateTime` 보다는 `LocalDateTime` 을 왜 사용해야하는가?
   https://www.daleseo.com/java8-zoned-date-time/

3. getter method를 handlebar에서 어떻게 호출해야 하는가? `{{getter에서 get부분을 제거한 이름}}`으로 호출한다.

4. replyCount를 안쓸 것 같아서 reply에 대한 자료구조를 생성했다. 그리고 replyCount는 재사용을 위해서 getReplyCount에서 reply에 대한 자료구조의 size를 리턴하도록 하였다.

## 운동

### 등

**Rear Pull Up** 8 → 6 → 6 → 6

## 나중에 읽어볼 것

[https://hue9010.github.io/spring/Spring-MVC-PUT,-DELETE-사용하기/](https://hue9010.github.io/spring/Spring-MVC-PUT,-DELETE-사용하기/)