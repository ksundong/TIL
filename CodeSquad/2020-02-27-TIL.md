# 2020-02-27-TIL

## 오늘 할 일

- [ ] STEP4 진행하기
- [x] 하체운동, 코어운동, 유연성
- [x] 프로그래머스 1문제 풀기
- [x] 코드스쿼드 수업
- [ ] HTTP 공부
- [x] 어노테이션 공부하기
- [ ] 회고하기

## 운동

- [x] 스트레칭
- [x] 하체운동
- [x] 코어운동

## 프로그래머스 1문제 풀기

- [x] 행렬의 덧셈

## 다른분들 리뷰 정리

### STEP2

- 생성시간에 대한 네이밍 `created` ⇒ `createdAt`, `createdTime` 등
- 기본 게터 세터는 유지하고, 새로운 메서드를 만들어서 사용하는 것을 권장
- findById를 사용하면 Optional로 받아오므로 쿼리를 한 번만 날리면 되니까 성능상 Optional을 다루는 것을 권장
  - 유무를 확인한 점은 잘했음
- 파라미터로 동일 클래스의 인스턴스가 들어왔을 때, 객체 필드에 직접 접근 가능함.
- `System.out.println` ⇒ `log.info()` 와 같은식으로 로깅을 하는 것을 권장.
- `@RequestMapping(..., method = RequestMethod.PUT)` ⇒ `@PutMapping(...)`
- [Optional의 활용](https://github.com/code-squad/java-qna/pull/159#discussion_r384533849)
  - if 절 flow를 다루는 것은 한 번 공부해 볼 만 한듯.
- 패스워드 검사는 getter를 사용하지 않고 메서드를 만들어서 활용해보길 권장.
- `ModelAndView` 와 `Model` 과 `View` String을 따로 쓰는 방법의 차이는 `ModelAndView` 는 `Model` 이 필요없음에도 불구하고 가져야하는 단점이 있기 때문에 나중에 따로 쓰는 기법이 추가됨
- `redirect`는 Client에 이 경로로 요청을 보내라는 것인데 `GET` 요청으로 오게됨.
- HTTP 1.1 method의 용례를 알고 사용하기. 협업/커뮤니케이션에 도움이 됨.
- 메서드 명은 되도록이면 동사로 지을 것
- 비밀번호 비교는 User의 메소드로 사용하는 편이 좀 더 객체지향에 가까움

## 애노테이션 공부

컴파일러만 애노테이션을 읽는줄 알았는데, 프로그램 별로 지원하는 애노테이션을 읽는 다는 사실을 알았다.

## STEP4 진행하기

- 다른 분들 리뷰 읽어보면서 User 업데이트시에 객체지향적 요소를 더하라는 얘기가 있어서 도입하고 있다.

## 코드스쿼드 강의

### 자바에서 못하는 것

C언어의 포인터는 Java의 참조변수와 비슷하다.

1. 배열 조작을 위해 포인터 사용
2. Call by reference를 위해 포인터 사용

자바의 한계(참조변수 자체로 객체를 변경 불가하다.)

자바의 참조변수는 읽기 전용 포인터다.

C언어 이중포인터...  ⇒ 포인터 변수를 매개변수로 받아 값을 고칠 수 있다. `& 변수` 바뀐다!

→ 더럽게 어렵다!

C++ 레퍼런스변수 엄청 간단하다 근데 문법은 안좋아!

1. 연산자 `&` 가 헷갈림
2. 바뀌는지 안바뀌는지 모름

C# `ref` 키워드 도입 ⇒ 짱좋아!

java 프로그래밍 언어적 특성과 객체 지향적 언어의 특성을 헷갈리지 말자

### JVM

JDK, JRE, JVM

`file` 명령어 사용해서 실행환경 확인가능

javac ⇒ `Person.java` → `Person.class` 

class 파일은 `Class Loader`가 읽어서 메모리에 올린다.

`main` 함수를 Entry Point(시작지점이라고 함)

가져올 수 있는 연결된 애들은 가져옴. 나머지는 필요하다는게 확인 될 때 동적으로 로딩함.

자바 아래에 여러 프로그램이 달려있다. 자바는 멀티스레드로 돌아감

JNI ⇒ JIT Compiler Byte code를 실시간으로 기계어로 바꿔주어서 엄청 빨라짐, 그래서 안씀

PC Register → JVM의 코드 실행을 위해서 필요한 값을 저장하는 공간 (PC + Register + alpha)

Stack

Heap

Method → 메소드, 클래스, 정적 변수

스프링 컨테이너가 빈들을 동적으로 로딩함.

클래스 로더는 로딩은 되는데 언로딩 기능은 없음.

Dynamic linkage → dll ⇒ 필요할 때 가져온다.

`per therad ` 자료구조

Method Area, Heap Area ⇒ 공유

나머지 thread 마다

`Animal a = new Human();` 하면 Animal 객체와 Human 객체가 모두 생기고 a는 Animal 을 가리킴

오버라이딩 하면 Animal의 것이 아니라 Human의 것이 사용됨.(dynamic loading)

Tomcat은 멀티쓰레드이기 때문에 Singleton의 Member 변수에 동시에 접근할 수 있다.

### HTTP1.1 / HTTP 2.0

#### HTTP1.1

파이프라이닝 ⇒ 일을 쪼갤 수 있다. ⇒ 쪼개서 연속적으로 할 수 있도록 한다.

#### HTTP 2.0

한 번에 주고 한 번에 받는다.

### TCP 3-way handshake

SYN ⇒ SYN ACK ⇒ ACK 값을 rand로 만들어서 +1

어떻게 부르는지 알아보기

OPTIONS 해당하는 URL에서 사용가능한 메소드를 가져옴.

### Stateless

HTTP는 Stateless

무전기 Stateless, half-duplex(송수신이 동시에 안됨), 핸드폰 Stateful, full-duplex(송수신 동시에 가능)

쿠키가 필요한 이유: 클라이언트를 식별을 하기 위해서

초기에 쿠키에 아이디 값만 넣어서 보냄 ⇒ 다른 사용자 인척 ⇒ (ID/PW)

세션은 임시 데이터 베이스(저장공간), 접속한 클라이언트 하나당 세션이 생김

HTTP 요청 하나당 임시 저장공간을 생성하는 것이 세션(세션은 메모리에 생기기 때문에 너무 커지면 안됨)

세션은 메모리나 Redis에 저장함.

세션과 쿠키의 동작방식은 면접 단골문제

Session은 동기화된 자료구조여서 동시접근에 대해서 걱정하지 않아도 됨.

