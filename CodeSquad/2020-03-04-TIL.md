# 2020-03-04-TIL

> 공동체의 이익과 연관이 없다면 남들을 생각하느라 네 여생을 허비하지 마라.
>
> 이 사람 또는 저 사람은 무엇을 하고 있을까, 왜 그렇게 할까, 그는 무엇을 말하고 생각하고 노리는 걸까 등등과 같이
>
> 너 자신의 지배적인 이성을 가지고 가까이에서 관찰할 수 없는 그런 일들을 생각함으로써
>
> 네가 해야 하는 다른 일들을 하지 못하게 되기 때문이다.
>
> *-명상록 3권 4장*

## 오늘 할 일

- [x] STEP5 진행하고 제출하기
  - [x] SessionUtils 따라 만들기
  - [x] Optional을 조건문으로 처리하는 방법 혹은 CustomException
  - [x] Entity를 조회시에는 Optional로 리턴해주기
  - [x] STEP5 내용은 다 했으므로 제출하기
- [ ] 회고하기
  - [ ] 2월 회고
  - [ ] 오늘의 회고
- [ ] 정리하기
  - [x] java bean 표준에 대한 정리
  - [ ] ORM의 역할에 대한 정리
  - [ ] 자바스크립트 이벤트 버블링, 델리게이션 찾아서 공부하기
  
- [ ] 스프링 자바 객체지향의 원리와 이해 읽기
  - [ ] 4장
  - [ ] 5장
  - [ ] 6장
- [x] 프로그래머스 1문제 풀기
  - [x] 다트 게임
- [x] 운동
  - [x] 전신
  - [x] 유연성
- [x] IntelliJ 웨비나 보기

## IntelliJ 웨비나 보기

웹 프로그래밍이래서 봤는데, FE에 대해서 다루고 있었다.

그래서 보다 말았다.

## STEP5 진행하고 제출하기

- [x] `SessionUtils` 따라 만들기
  - 따라 만들어봤는데, 나는 좀 더 `Optional`을 사용하고 싶어서 Optional을 사용해보았다.
  - 아직 `Optional`을 어떻게 하면 잘 다룰 수 있는지 모르겠다.. 어려워...
- [x] `Optional`을 조건문으로 처리하는 방법 혹은 `CustomException`
  - `CustomException`을 사용하는 방법을 채택했다. 아직 `Optional` 이랑 친구가 아닌가보다.
- [x] Entity를 조회시에는 Optional로 리턴해주기
  - 개선된 코드를 적용했다.
- [x] STEP5 내용은 다 했으므로 제출하기
  - 제출하면서 진행하면서 의문사항이 든 점, 남아있는 문제에 대해 적었다.
  - 리뷰를 받으면서 성장하는 느낌이 확실히 든다.
  - 근데 약간 성격좀 고쳐야겠다... 어려우면 포기하는게 내 성격인데, 코드스쿼드에서 고쳐서 나가자!

- 참고링크 정리
  - [Spring Guide - Exception 전략](https://cheese10yun.github.io/spring-guide-exception/)
  - [ResponseStatusException - Baeldung](https://www.baeldung.com/spring-response-status-exception)
  - [(Spring Boot) 오류 처리에 대해 - WhiteLabelError Page가 어떻게 생길까?](https://supawer0728.github.io/2019/04/04/spring-error-handling/)
  - [@ControllerAdvice, @ExceptionHandler를 이용한 예외처리 분리, 통합](https://jeong-pro.tistory.com/195)
    - 추가적으로 `@RestController`에서 발생한 `Exception`은 `@RestControllerAdvice`를 사용해야한다.
  - [Java Optional 바르게 쓰기](http://homoefficio.github.io/2019/10/03/Java-Optional-바르게-쓰기/)
  - [자바 옵셔널 활용](https://jdm.kr/blog/234)
  - [자바 옵셔널을 활용하기 위해서는 함수형 사고를 해야한다.](https://www.daleseo.com/java8-optional-after/)
    - [자바 옵셔널 활용 예](https://www.daleseo.com/java8-optional-effective/)

## 프로그래머스 1문제 풀기

- [x] 다트 게임
  - [정규표현식 학습사이트](https://regexone.com/)
  - [자바 named-capturing-groups](https://www.logicbig.com/tutorials/core-java-tutorial/java-regular-expressions/named-captruing-groups.html)
  - [위에 이어서 StackOverFlow 질문](https://stackoverflow.com/questions/415580/regex-named-groups-in-java)
  - 남들은 안하는 정규표현식을 써서 풀었다. 그냥 써보고 싶었다.
  - 속도도 나름 잘 나온것 같기도..? 2ms 내외로 나온 것 같다.

## 공부할 거리

- 익셉션 핸들러에 대해서 공부하기
- 상태코드에 대해서 공부하기 (정리해둬도 좋을 것 같다.)
- WhitelabelError Page가 어떻게 만들어지는지 공부해보기.

## JavaBeans 표준

[출처](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88)

- EJB(Enterprise Java Beans) 와 혼동해선 안된다.

### 자바빈즈의 관례

- 클래스는 직렬화 되어야 한다. (클래스의 상태를 지속적으로 저장 혹은 복원시키기 위해)
  - `implements java.io.Serializable`
- 클래스는 기본 생성자를 가지고 있어야한다.
  - `public TestClass() {}`
- 모든 `property`들은 `private` 해야한다.
- 클래스의 `property` 들은 `get`, `set` 또는 표준 명명법을 따르는 메소드를 사용해 접근 할 수 있어야 한다.
- 클래스는 필요한 이벤트 처리 메서드를 포함하고 있어야 한다.
- `boolean` 형의 `getter` 는 `is`로 시작한다.
- 영속성이 있어야한다.(?) ⇒ Bean의 현재 상태를 비휘발성의 저장소에 저장하고 나중에 꺼낼 수 있어야 한다.

### 장점

- Bean의 속성, 이벤트, 메소드는 다른 애플리케이션에 노출 가능합니다.
- Bean을 구성하는데 도움이 되는 보조 프로그램이 제공될 수 있습니다.
- Bean의 설정정보는 영속성 저장소에 저장하고 복원할 수 있습니다.

### 단점

- 기본 생성자가 있는 클래스는 유효하지 않은 상태에서 인스턴스화 될 수 있습니다.
  - 수동으로 생성하는 경우 이러한 문제가 생길 수 있습니다.
  - 컴파일러가 이러한 문제를 감지할 수 없습니다.
- Bean은 기본적으로 변경가능하므로, 불변 객체가 제공하는 이점이 없습니다.
- 모든 `property`에 대해 `getter`를 만들고 대부분의 `property`에 대해 `setter`를 만들어야 하는 경우 많은 양의 코드가 생깁니다.
  - `Lombok`을 이용해서 완화할 수 있습니다.

### 왜 JavaBeans를 사용하는가?

Java Bean은 Builder Tool에서 시각적으로 조작할 수 있는 재사용 가능한 소프트웨어 컴포넌트입니다.

서로 다른 Builder에서 편리하게 Java Class를 쓸 수 있도록 합니다.

즉, 어디서나 공통의 Convention을 지키며 사용할 수 있는 것이고, 따라서 별도의 문서 없이 쉽고 일관된 방식으로 사용할 수 있음을 의미합니다.

### 왜 private 한 필드로 이루어져 있는가?

필드에 대한 완벽한 제어를 위함입니다. 또한 `Encapsulation`을 지키기 위함입니다.

### 왜 기본 생성자를 사용하는가?

다른 프로그램에서 객체를 생성하려고 하는데, 생성자에 `Argument`가 존재한다면

`Argument`가 몇 개인지, 어떤 필드가 필요한지 알아야 합니다.

하지만, `Argument`가 없다면 어떨까요? 필요한 데이터만 할당해주면 됩니다.

즉, 객체를 런타임(Runtime)에 생성해주는 프로그램이 오브젝트 생성을 하고, `getter/setter`를 호출해서 할당하도록 하면 `Argument`에 관여받지 않고, 할당이 가능해집니다.

### 왜 java.io.Serializable 인터페이스를 구현하여 직렬화하는가?

우리는 데이터를 저장할 수도 있고 다시 읽을 수도 있고, 네트워크로 전송하거나 받아올 수 있습니다.

File I/O, 통신을 할 때, 사용하는 Stream으로 변환을 시켜줘야 하는데, 이 과정을 `Serialization`이라고 부릅니다.

또한, JavaBean을 왜 사용하는지에 대해서 설명할 때, 서로 다른 Builder에서 편리하게 공통의 Convention을 지키면서 사용하기 위해서 Java Bean을 사용한다고 하였습니다.

즉, JavaBeans는 이러한 과정을 수행할 용도로 `Serializable`을 구현하도록 사양이 정해졌다고 볼 수 있겠습니다.

- 같이 볼 내용. POJO(Plain Old Java Object)
  - EJB의 단점을 보완하기 위함.
  - 한 번 알아보고 정리해보자.