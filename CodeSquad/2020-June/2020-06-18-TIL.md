# 2020-06-18-TIL

## 오늘 할 일

- [x] 스크럼

- [x] 오늘 할 일 계획하기

- [x] API 구현 이어서 하기
- [x] 알고리즘 문제 풀기
- [x] 운동하기
- [x] 백엔드 수업듣기
- [x] JPA 강의 듣기

- [x] 커리어 코칭 듣기

## 스크럼

- 어제 한 일
    - API 개발 조금
    - 백엔드 회식
    - 코드스쿼드 수업 듣기
- 오늘 할 일
    - 알고리즘 문제풀기
    - 운동하기
    - API 개발하기
    - JPA 강의 듣기
    - 백엔드 수업 듣기
    - 커리어 코칭 듣기
- 컨디션
    - 어제 늦게자서 그런가 아직 잠이 덜 깬 느낌이에요.
- 고민거리
    - 오늘도 뭔가 개인 공부 할 시간이 없는 것 같네요.
        - 프로젝트 + 강의 + 개인공부 병행이 쉽지 않죠ㅠ

## 오늘 할 일

알고리즘 1~2문제 풀기

백엔드 수업듣고 커리어 코칭 듣기

운동하기

JPA 강의 듣기

API 구현하기

## 알고리즘 문제풀기

백준 사칙연산을 풀었는데, int 연산 후에 char형을 쓰지 말아야겠다고 생각했다.

그래서 계속 틀렸다.. 너무 슬프다...

## 백엔드 수업(레디스)

하둡의 장점은 대용량 처리가 가능하다는 장점이 있다. 하지만 느리다.

분산처리도 장점이긴 하지만 사용자의 목적은 대용량이 더 크다.

레디스는 MySQL보다 빠르지만, 저장 용량이 적다.

레디스는 수평확장을 할 수 있는데 3copy 저장을 통해서 내구성을 유지한다.

데이터를 기록하는 행동 자체를 로깅을 한다.

#### 수평 확장

1. 여러 대의 서버를 두어서 clustering 하는 방법

2. primary → secondary

서버가 두대만 있으면 되는 2번을 많이 쓴다.

### 레디스의 용도

- 간단 KV 데이터베이스로 사용 가능
- **주로 캐시로 많이 사용한다.**
- 쉽게 익힐 수 있다는 장점.

속도가 굉장히 빠르다. 하지만 MainThread 하나밖에 없다.

### 레디스 설치

레디스는 소스 설치가 많다.

`set`, `get`, `exists`

try.redis.io

`:`을 쓰는 이유: 관행

`incr` 증가하는 것: atomic해서 값이 변경되지 않음.

### 캐시에 관련된 기능

`expire` ⇒ 만료시간을 지정한다.

`ttl` ⇒ time to live 살아있는 시간

` persist` ⇒ 영속화시킨다. 만료시간이 없어짐



캐싱전략(오래된 친구가 먼저나감)

### 리스트

rpush: 오른쪽에 넣는다.

lpush: 왼쪽에 넣는다.

lrange: 가져오기

llen: 길이가져오기

### Set

`sadd`: 삽입

`srem`: 제거

`sismember`: 해당 레코드가 존재하는지

`smembers`: 셋에 존재하는 데이터 모두 가져오기

`sunion`: 합집합

### AWS ElastiCache

- Redis
  - Cluster(샤딩으로 저장)
- Memcached

샤딩은 데이터를 분산 저장하는 것

관리 부담이 없기 때문에 좋다.

메시징(Redis pub/sub) ⇒ subscribe를 먼저 하고 publish를 할 수 있다. (신문 구독)

pub/sub은 비동기 처리할 때 좋다.

### 캐시 운영 전략

⇒ 캐시는 비용이다..

캐시로 인해서 장애가 발생할 확률이 높아진다.

캐시는 Lazy Loading, Write-Through

캐시를 어떤걸 할까?

1. 자주 액세스되는 데이터
2. 최근에 추가된 데이터

#### Lazy Loading

캐시에 있는지 확인하고 없으면 데이터베이스를 거침

cache hit를 하지 못하면 더 오래걸린다.

90% 정도 캐싱이된다면 좋다.

#### Write-Through

데이터를 추가하거나 업데이트하면 캐시에도 업데이트 한다.

껐다 킬 때 문제가 생길수도 있다.

데이터가 잘 안맞을 수도 있다.

사용자가 접근하지 않으면 캐싱을 삭제하는 것도 방법이다.

### 스프링과 Redis

Spring Data Redis

Session Storage를 Redis를 쓴다. 세션이 유지된다.

클러스터링으로 여러 서버에서도 사용할 수 있다.

## 커리어 설계

공부도 중요하지만, 건강과 멘탈(마음)을 잘 챙기자

왜 뭐가 잘못되었는지 분석을 하고 회고를 하기

회사는 한 곳만 다니는 것도 아니고 그런 매너를 잘 지키자.

이력서는 한 장으로 끝내버리자

자체 서비스로 돈을 벌고 있는지가 중요하다.

너무 한 언어만 고집하지 말자.

인터뷰를 가서 보면 어떤 분위기인지 알 수 있다.

한 두개를 깊게 파본거랑 여러개를 파는 것 중에서 한 두개를 깊게 파본 경험을 가지는 것을 추천한다.

포트폴리오: 

주니어 신입을 뽑는 이유: 시니어를 잡일을 안시키기 위해서

회사를 따져보는 것도 중요하다.

주니어나 신입때는 연봉에 연연하지 않는 것을 추천

학습을 통해서 잘한다는 것을 어필하자.

첫 직장을 고를 때 1년 후의 내가 어떻게 성장해 있을지 기대치가 높은 회사를 지원하자.

나에게 가장 좋은 회사를 지원하자. (큰 서비스를 하는 회사도 좋음., 내가 이룰 수 있는게 굉장히 기댓값이 높은 서비스도 추천)

5년 후에 나는 어떻게 될 것인가?를 생각하자 연간 계획을 세워놓고 도전하자.

자기가 하고싶은 일을 열심히 하다보면 좋은 결과가 올 수도 있다.(운이 좋으면) ⇒ 20대 때 도전을 많이 해보자.

내가 나 자신을 잘 알고 나 자신을 잘 붙들고 있을 때, 좋은 결과를 이끌어 낼 수 있다.

## JPA 강의 듣기

### Entity 설계

- N:N 관계는 1:N N:1 관계로 풀어낸다.
- 임베디드 타입 정보는 그대로 DB에 넣는다.

#### ITEM 테이블 설계

- 싱글 테이블 전략(상속관계 매핑전략 중 가장 단순한 전략): 지저분하지만 성능은 좋음

ORDER BY 예약어 때문에 보통 테이블명은 ORDERS로 함.

관계형 DB는 일반적인 설계로는 다대다 관계를 맺을 수 없기 때문에 매핑 테이블로 풀어내야함.

### 연관관계 매핑 분석

연관 관계에서는 연관 관계의 주인을 결정지어줘야 한다.

DB에서는 FK가 있는게 항상 다가 된다.

mappedBy로 가져오는 것은 읽기 전용이어서 주인쪽에서 값을 바꾸어주어야 한다.

FK가 있는 쪽이 연관관계의 주인이다.(외래키의 관리 주체)

외래키가 가까운 곳에 있는 것을 연관관계의 주인으로 잡는다는 대원칙... 그래야 모든 것이 편하다.

예를 들어서 일대다라면 다쪽에 무조건 외래키가 있으므로 다를 연관관계의 주인으로 하면 된다.

### 엔티티 클래스 개발

- Getter만 쓰고, Setter는 꼭 필요한 경우에 사용하기
- JPA 내장 타입을 쓸 때에는 내장 타입 클래스에 `@Embeddable`을 선언해주고, 내장타입을 사용할 클래스에서 `@Embedded` 를 사용해준다.
  둘 중 하나만 있어도 되지만, 둘 다 써주는 편이다.
  왜냐면 내장타입인지 알 수 있다는 장점이 있기 때문임.
- 보통 DBA들은 id라는 컬럼명을 선호하지 않기 때문에 테이블명_id로 만드는 편입니다.
- 연관관계 매핑시에 `@ManyToOne`과 `@OneToMany`를 적어야한다면 양쪽 모두 적어주는 편임.
- `@JoinColumn` 을 사용한다면, name에 foreign key의 명칭을 적어준다.
- 양방향 연관관계를 할 때 중요한 것은 연관관계의 주인을 잘 정해줘야 한다.
  - FK가 있는 녀석이 업데이트를 하도록 규약을 정했다.
  - 주인이 아닌 쪽은 mappedBy라는 어노테이션의 파라미터를 지정해주고 이 때, 참조하는 멤버변수를 입력해주면 된다.
  - mappedBy를 지정해주면, 내가 매핑을 하는 것이 아니라 읽기전용인 거울일 뿐이야. 이렇게 생각하고, 변경을 해도 영속성에 영향을 미치지 않는다.
- LocalDateTime은 따로 JPA 날짜관련 어노테이션을 붙여주지 않아도 된다.
- 상속관계 매핑을 할 때에는 상속관계 전략을 잡아주어야 한다.
  - 부모 클래스에 잡아주어야 한다.
  - JOINED: 가장 정규화된 스타일
  - SINGLE_TABLE: 한 테이블로 관리
  - TABLE_PER_CLASS: 클래스 마다 테이블 생성
- `@DiscriminatorColumn` 에서 구분을 할 테이블 컬럼을 지정해준다.
- `@Enumerated`를 넣을 때 주의해야 한다. 왜냐면 EnumType을 지정해줄 수 있는데 여기서 중요한 것이 ORDINAL이 기본값이다.
  - 근데 이 ORDINAL의 가장 큰 문제점이 숫자형이어서 저장될 때 숫자순서로 저장이 된다는 것이다. 그렇게 된다면, 변경으로 인해 Enum값 사이에 새로운 값이 추가 될 경우 동작이 불안정해진다.
  - 따라서 STRING으로 지정해준다. 몇 글자 아끼려다가 장애내는 것보다 낫다.
- 1:1 관계를 매핑할 때, 외래키를 어디에 주는지가 고민...
  - 보통 액세스가 많은 곳에 둔다.
- ManyToMany를 실무에서 쓰지말라고 하는 이유.
  - 딱 매핑되는 테이블만 지정 가능해서, 그 외의 부가정보를 넣을 수 없기 때문에...
- 같은 클래스의 매핑은 다른 엔티티를 매핑하는 것이라고 생각하고 매핑을 해주면 된다.
- foreign_key를 써야되나요? 정합성을 맞추려면 걸어주고, 실시간 서비스라면 고민한다.
- 값 타입(VT)은 Immutable하게 설계되어야한다.
  - 생성할 때에만 값을 제공하고, getter만 제공한다.
- JPA 스펙에서는 기본생성자가 없으면 호출이 안되기 때문에 protected로 기본생성자를 선언하는 것을 권장한다.
  - 리플렉션이나 프록시 같은 기술들로 값을 세팅하기 때문임.
  - 하이버네이트는 더 좁힐 수 있다.

- 하이버네이트가 작성해준 DDL은 그대로 사용하지 말고 정제해서 사용하자

## 맥에서 포트 사용중인 프로세스 찾기

`lsof -i tcp:8080`

`kill $(lsof -i tcp:8080)`

## 오늘의 회고

오늘은 하루를 알차게 쓴 것 같다.

일단 하고자 했던 일을 다 마무리했고, 뭔가 걱정거리도 많이 사라졌던 것 같다.

내가 할 수 있는 최선을 하루하루 다한다면, 내가 원하는 인간이 되어있겠다고 생각이 든 하루였다.

노력하다보면 잘 되겠지!!

## 내일 할 일

- [ ] Entity 설계도 그리기
- [ ] 스크럼
- [ ] 오늘 할 일 계획하기
- [ ] 알고리즘 문제풀기
- [ ] 운동하기
- [ ] API 구현하기
- [ ] JPA 강의듣기

