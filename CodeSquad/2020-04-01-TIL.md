# 2020-04-01-TIL

## 오늘 할 일

- [x] 스크럼
- [x] 이슈 생성
- [x] 프로젝트 수행
- [x] JK 강의 SOLID와 객체지향
- [x] 팀 회고

## 스크럼

### 🎒Dion:

#### 🌝어제와 ☀️오늘

어제는 생각보다 일찍 예정했던게 끝나서 발 뻗고 잠자다가 장애나는 꿈을 꿔서 황급히 슬랙을 열었습니다.

다행히 잘 돌아가고 있군요. ~~휴...~~

어제 컨디션이 좀 안좋아서 일찍 자러 갔는데, 결국 잠을 설쳐서 도루묵인 것 같지만, 컨디션 자체는 어제보다 좋네요.

##### 오늘 할 일

- [x] API 작성(24시간 기록 API 구현)
- [x] API 작성(근처 측정소 구하는 API 구현)

일단 목표는 이 정도로 잡고, 추가 목표는 다음과 같습니다.

- [ ] API 테스트 코드 작성

#### 📢Talk Talk

사회적 거리두기가 얼마 남지 않았습니다. 건강관리 유의하셨으면 좋겠습니다.

API 제대로 만들어서 구현에 도움을 드리고 싶네요!

## 이슈 생성

- [x] API 작성(24시간 기록 API 구현)
- [x] API 작성(근처 측정소 구하는 API 구현)

## 강의 다시 듣기

객체지향 프로그래밍(OOP)

구현이 다 되었다고 구현이 바로되진 않는다. 사고의 흐름이 끊기지 않게 반복해줘야 한다.

## JK 강의듣기(공통 수업)

- OOP는 패러다임임

- Design Pattern은 여러 번 구현하면서 패턴화 된 것이다. 일부러 쓰려고 할 필요는 없다!

- 클래스와 인스턴스의 차이

  - 클래스는 추상적
  - 인스턴스는 구체적

- 클래스를 더 추상화하면 인터페이스가 됨

- 객체는 클래스와, 인스턴스를 합쳐서 의미한다(왜냐하면 객체는 속성(property)와 행위(behavior)가 있어야 하기 때문임)

  - 클래스는 shared part, 인스턴스는 private part 라고도 함.

- 옛날 프로그램은 그냥 메모리에 값이 써져있었음. (코드화 되어있었음) procedure(절차)대로 프로그래밍

  - 보기 힘드니까 구조화의 필요성이 생김
  - 그 다음에 객체지향이 생김

  1. 프로시저 추상화: 절차적 추상화(루틴과 서브루틴(:루틴을 나누는 것))
  2. 데이터는 아직도 복잡함. → 관련 있는 데이터와 관련 없는 데이터를 나눔(절차 지향 ⇒ 구조적 프로그래밍 패러다임)
  3. goto → 흐름제어 → 반복문..조건문

요즘 언어들은 당연히 구조적 프로그래밍이 됨.(goto 문 없이 제어흐름의 전환)

근래 들어서 함수형 프로그래밍이 가능해짐(그래서 떠올랐다.)

7~80년대 PC가 대두되면서 GUI 프로그래밍이 급부상

제록스 (사무 자동화) → 복사기 → 돈을 잘 벌어서 PARC 연구소 설립

- 앨런 케이 → 데이터 중심 프로시저 추상화(상속과 다형성 지원: 객체지향의 대중화)
  - 이전에 이미 Class Interface등의 용어는 다른 언어에서 사용함

추상 데이터 타입(Ruby) vs 객체지향(객체지향 언어를 표방하는 언어들)

- 추상 데이터 타입은 비교문이 들어갈 수 밖에 없음.

구현상속을 쓰기보다는 인터페이스 상속을 써라

Duck Type 인터페이스를 채택해서 구현하면 돼!

**객체지향에서 클래스를 쓰는 이유: ** 타입으로 쓰기 위해서.

세부적인 것으로 갈 수록 위의 속성들을 다 가진다. (생물의 분류와 유사함)

타입, 클래스를 선언한다는 것은 ~~?

### 무엇이 Encapsulation인가?

1. property가 얼마나 보호되어있는가?
2. 내부에서 필요한 값을 외부에서 받아서 생성한다.
3. **객체 자체를 비교한다. (클래스에서 비교 메서드 생성) → 타입 자체를 활용하려고 노력해라. 우리가 만든 타입도 타입이고, 객체다. 이걸 다루려고 노력해야 한다.**
4. 복잡성을 감추는 새로운 타입을 만들자
5. 상위 클래스는 하위 클래스보다 더 단순하고, 하위 클래스는 복잡하지만 상위 클래스에서 알 필요는 없게된다.

### 객체지향 설계

기능 분해(Functional decomposition)와 복잡성을 감추기

값을 가지고 무엇을 하려고 하지말고, 객체자체를 가지고 무엇을 하려고 하세요.

객체지향의 사실과 오해 꼭 읽어보기

협력: 여왕이 한 마디하면 하위의 개체들이 엄청 일을 함

동양사람이 자주하는 실수: Context가 같은 객체를 묶어버림

객체지향 프로그래밍과 현실이 다른 점 (객체들이 모두 기능을 가지고 있음)

객체가 일하도록 시킨다.

### SOLID 원칙

이렇게 하니까 좋더라(근데 진리는 아니다.)

자바에서는 다 되는데... 다른 언어는 안되는 경우도 있다.(e.g. JS)

1. SRP: 응집도, 단일 책임(클래스, 모듈, 함수 등)
2. OCP: 확장 가능, 변경 닫음
3. LSP: 상속, 대체 가능해야 한다. → 일부러 깨는 경우도 있다.
4. DIP: 상위 모듈과 하위 모듈의 의존관계(의존성 역전)
5. ISP: 객체가 가지고 있는 인터페이스는 안쓰는걸 분리

#### 응집도

응집도 있게 만들어야 한다. (관련있는 것 끼리 묶여야 한다.)

LCOM4는 1이 더 좋은 것(같이 쓰는 애들이 뭉쳐있다.)

그 순간에 그것이 의미가 있는가에 대한 snapshot임.

#### 의존성

내부에서 생성해서 사용해야 한다.

Player → CardDeck(구체타입 (concrete type)에 의존)

#### 열림-닫힘 원칙 OCP

추상화된 대상에 의존

##### 열거 타입을 쓰는이유

열거 타입을 쓰면 switch문이 생김. (하나만 바꿔도 switch 문을 전부 다 바꿔야 함)

OCP 위배

열거 타입을 써도 되는경우 (행위를 갖지 않고, 값만 가지는 경우)

Uncle Bob은 값 객체를 객체라고 안하고 DS(Data Structure)라고 부름.

어떤 타입이 구체화된 타입에 의존하지 않고 추상화된 타입에 의존하도록 하고 추상화된 타입을 구현한 구체타입으로 사용한다.

### ISP

각각의 인터페이스도 참조하는 애들 별로 나눈다.

### DIP

의존성: 얘가 얘가 있어야지만 사용할 수 있다. (객체 생성 후 소유, 소유한 객체의 호출)

- 생성을 하지 않고, 상위 모듈에서 생성해서 하위 모듈에 주입을 해준다.
- DI(Dependency Injection)과 Inversion의 차이를 잘 알아야 한다.
- Injection은 Inversion의 한 방법일 뿐임.
- Interface에 의존하도록 만드는 것이 한 방법이다. (인터페이스를 이용해서 의존성을 뒤집는 것.)
- System Framework는 의존적이지만 무시하자. (거의 바뀌지 않는다.)
- 좋은 Framework는 바뀌어도 거의 영향을 받지 않도록 구현된다. (거의 구체타입이 아님.)
- 소프트웨어를 더 유연한구조로 만들기위함

### 책임 할당하기

- 데이터보다 행동을 먼저 결정해라(외부에서 무엇을 요청하는지)
  - 외부에 제공하는 행동
- 협력이라는 문맥 안에서 책임을 결정하라
  - 클래스를 결정하고 그 클래스의 책임을 찾기보다는
    메시지를 결정하고 이 메시지를 누구에게 전송할 지 찾아라.
- 책임 주도 설계와 GRASP 패턴

### 도메인

뭔가 익숙한 것(도메인 지식) → 잘 알 수록 프로그래밍에 유리함

도메인 그림, 설계도 계속 바뀐다.

### GRASP 패턴

리팩토링 1판의 배경이 되는 것 (비디오 테이프 대여점)

1판에서 가장 질문이 많이 나온 것: 비디오 테이프 대여점이 뭐에요? ⇒ 도메인 지식이 없음

#### 도메인 개념: 극장

어떤 행위가 중요한지 생각한다. (메시지를 전송할 객체와 메시지를 받을 객체를 정한다.)

##### 다른 객체와 협력을 해야할 때, 높은 응집도와 낮은 결합도를 생각한다.

변경에 독립적이도록 설계한다.

인터페이스를 도입하면 결합도가 낮아지는 효과가 있다.(인터페이스가 바뀌지 않는 한.)

#### Creator: B가 A를 생성하게 하는 경우

다형성을 적용하면 상위에서 분기문을 없앨 수 있다. (단, 메소드 형식이 같아야 한다.)

설계를 해놓고 구현을 해본 다음, 변경이 생기는 요소를 찾아내서, 응집도가 높도록 하고, ~~

다형성은 메시지를 보내서 메시지를 보내면, 받는 객체가 무엇이냐에 따라서 메소드의 실행이 달라진다는 것입니다.

디미터 법칙: 디미터 프로젝트를 하면서 나온 법칙

- 인접한 객체와만 협력한다.
- `.`을 하나만 찍자

상위 객체와 하위 객체의 포함관계에 따라서 접근해서 처리하자.

모든 경우에 적용하라는 얘기는 아니다.

프로시저와 함수를 나누어서 구현하자(프로시저는 내부 상태를 변경(mutable), 함수는 값을 반환(immutable))

새로운 객체를 반환하는 식으로 불변하게 만드는 것도 있음. (메모리를 낭비하지 않나? → 이전 메모리 상태를 유지하는 것으로 만들어내는 기법도 생김)

오늘날 대부분의 경우 객체가 이전하고 똑같은 상태는 아님.

**OOP가 끝은 아니다.** 멀티 패러다임이 생기고 있음. FP와 OOP 두 가지의 의미를 어떻게 구현할 수 있는지 잘 생각해보자.

## 카카오 API 호출 보낼 때, API Key는 Header에 담아야 함.

RestTemplate에 담는 방법이 조금 다르다.

```java
URI kakaoApiRequestUrl = new URI(KAKAO_API_TRANS_GEO_COORDINATE_SYSTEM_AND_X + longitude
        + AND_Y + latitude + AND_INPUT_COORDINATE_SYSTEM_WGS84 + AND_OUTPUT_COORDINATE_SYSTEM_TM);

HttpHeaders headers = new HttpHeaders();
headers.set("Authorization", "KakaoAK " + KAKAO_API_APP_KEY);

HttpEntity<String> httpEntity = new HttpEntity<>(headers);

String response = restTemplate.exchange(kakaoApiRequestUrl, HttpMethod.GET, httpEntity, String.class).getBody();
```

이런식으로 하면 된다. ~~참 쉽죠??~~

## 오늘의 회고

- 잘한 점
  - 오늘 목표했던 것을 다 끝냈다.
  - 생각보다 코드가 술술 나와서 금방 했다.
  - 수업에 집중도 있게 참여를 했다. (오늘은 만족!)
  - 프론트에서 구현에 어려움이 있어서 도와드렸다! (햄보케!!)
- 못한 점
  - 혼자 너무 여유만만인듯..?
- 보완점
  - 코드 퀄리티에 신경쓰기
  - 도전할꺼리 만들기

## 내일 할 일

- [ ] 테스트 코드 작성
- [ ] 배치 작업 만들기
- [ ] GIF 쪼개서 파일로 만들기
- [ ] 리팩토링?
- [ ] 스크럼
- [ ] 이슈 작성
- [ ] 프로젝트 진행
- [ ] 팀 회고

