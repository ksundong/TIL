# 2020-04-19-TIL

## 오늘 할 일

- [ ] Java 학습 테스트 다시 해보기
- [ ] 최범균 스프링 1장 보기
- [ ] 인프런 알고리즘 강의 보기
- [ ] 인프런 백기선님 강의 보기
- [x] 우아한 객체지향 보기
- [ ] 생활코딩 OAuth 2.0 영상 보기

## 우아한 객체지향

관계의 방향 = 협력의 방향 = 의존성의 방향

### 관계의 종류 결정 순서

연관관계 (협력을 위한 영구적인 탐색 구조): 되게 빈번하게 접근함
탐색가능성(navigability): A를 알면 B를 찾아갈 수 있어요.
협력이 영구적으로 유지되어야 해.
**일반적으로** 연관관계를 구현하는 방법: 객체 참조, 다른 방법도 있다.

의존관계 (협력을 위해 일시적으로 필요한 의존성)

### 코드로 구현할 때 유의할 점

1. 메소드를 만들고 메시지를 결정하는 것이 아니라, **메시지를 만들고 메시지를 바탕으로 메소드를 만들어야 한다.**(37:20)

2. 이 설계가 정말 괜찮은 가를 알기 위해서는 툴로 그림을 그리는 것이 아니라 손으로 그림을 그려가면서 의존성의 연관관계를 확인한다.

   자바에서는 패키지로 레이어를 구분한다.(서비스, 도메인 같은...)

3. 양방향 연관관계가 있다면 뭔가 이상하다고 생각해야한다.

   이를 해결하는 방법

   1. 중간 객체를 이용해서 의존성 사이클 끊기

      중간에 변환이 가능한 클래스를 만들어서 연관관계를 끊는다.(이상해 보일 수 있지만 의존 역전 원칙(DIP)을 사용한 것임)
      구체적인 것에 의존하지 않고 추상적인 것에 의존을 하도록 함.

### 개발에서 추상화의 진정한 의미

- 사람들의 추상화에 대한 선입견: 추상 클래스나 인터페이스만 추상화의 대상이 될 수 있다고 생각함.
      But, 구체클래스도 추상화의 대상이 될 수 있음.
- 개발에서 추상화의 의미는 어떤 것에 비해서, 어떤 것이 **잘 변하지 않는 것**을 의미한다.
- 이를 사용하면 재사용성이 증가하게 됨.
- 이를 꼭 해야한다는 것은 아니고 의존성을 보면서, 설계의 개선 방향을 생각할 수 있는 것이 중요하다.

### 연관관계 다시 보기

연관관계의 코드 구현중 하나인 객체참조에는 문제점이 있음.

1. 두 객체 사이의 결합도가 높아짐

2. 성능 문제 - 어디까지 조회할 것인가? (Lazy Loding 문제가 나옴)

3. 수정할 때, 도메인 규칙을 함께 적용해야 하는 객체의 범위가 모호함.

   트랜잭션의 경계도 모호해짐. (DB, DataMapping에서 이슈가 발생함)

4. 이렇게 되면 결국에 트랜잭션 경합이 일어나서 성능이 떨어지는 이슈가 발생함.

### 객체 참조가 정말 필요한가?

#### 객체 참조의 문제점

모든게 다 연결 되어있다는 것이 문제임.

어떤 객체라도 다 접근 가능하고, 어떤 객체라도 함께 수정 가능함.

객체 참조는 영구적인 결합이기 때문에 결합도가 가장 높은 의존성임.

**그러므로, 필요한 경우에는 객체 참조를 다 끊어주는 게 좋다.**

#### 객체 참조를 끊는 방법

1. Repository를 통한 탐색(약한 결합도) ⇒ Shop이 아니라 Id를 들도록 함.

   실제로 Repository에 들어갈 인터페이스는 연관 관계를 구현할 수 있는 Operation이 들어가 주어야 함.

   파라미터로 받은 타입을 가지고 이 객체를 찾을 수 있다는 의미임.

   이것이 깨지는 이유는 조회 로직이나 어드민 로직이 들어가기 때문임. (도메인 자체로는 문제가 없다.)

   비즈니스 로직 측면에서는 다 연관관계를 구현하기 위한 것이 들어가야 함.

#### 어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?

간단한 규칙

1. 함께 생성되고함께 삭제되는 객체들을 함께 묶어라
2. 도메인 제약사항을 공유하는 객체들을 함께 묶어라
3. 가능하면 분리하라

이걸 결정하는 것이 도메인 룰임. (도메인 관점에서 어떤 데이터를 같이 처리해야할 지 결정을 해주어야 한다.)

**경계 안의 객체는 같이 묶어주는 편이 좋다.**

경계 밖의 객체는 ID를 통해 접근 할 수 있도록 한다.

### 왜 책이나 강의에선 객체 참조로 구현되어 있는가?

객체 참조로 설명하는 편이 객체간의 메시지를 통한 협력을 표현하기 좋기 떄문,

실무에서는 성능 이슈 등의 현실적인 제약으로 분리를 하는 것이 더 좋다.

Lazy Loding과 Eager Loding은 실질적으로 이 경계에서 결정하면 된다.

mongoDB에 저장하는 단위가 바로 이 경계이다.

**그룹은 트랜잭션/조회/비즈니스 제약의 단위**이다.

### 하지만 컴파일 에러가 발생한다.

이를 해결하는 방법은 바로 객체를 직접 참조하는 로직을 다른 객체로 옮기는 것이다.

이렇게 하면 좋은점

1. 여러 객체를 오가면서 로직을 파악하지 않아도 된다.

   처음엔 로직을 파악하기 쉬웠음. 하지만? 다른 사람이 볼 떄에는 여러 객체를 오가야 함.

2. 낮은 응집도의 객체를 높은 응집도의 객체로 변경할 수 있음.

   응집도는 관련된 책임의 집합. 응집도는 같이 변경되는 것이 같이 있을 때 높아지고, 같이 변경되지 않는 것이 같이 있을 때 낮아짐. 변경은 객체의 상태가 바뀌는 것이 아니라, 코드의 수정을 의미함.

### 때로는 절차지향이 객체지향보다 좋을 때가 있다.

전체 Flow를 한 눈에 볼 수 있는 장점이 있음. (물론 단위테스트가 힘들어지긴 함.)

하지만 사람들이 일반적으로 가지는 강박관념 중에 하나가 validation 로직을 객체가 가지고 있어야 한다는 생각임.

안가져도 무방하다! (단순 객체 자체를 validation하는 것은 그 객체가 가지고 있어야하는게 맞지만, 하위 객체를 validation한다면 따로 빼주는 편이 좋다.)

결합도는 높이지만 응집도를 낮추는 코딩이 될 수 있음을 명심하자.

객체지향이 다 정답은 아니다. 이에 대한 Trade-off를 잘 해야한다.

### 또 컴파일 에러가 발생한다.

본질: 도메인 로직의 순차적 실행

해결방법

1. 서비스를 사용하는 것.

   절차지향 로직으로 변경한다.

   어떤 비즈니스 플로우 자체가 한 눈에 보이게 된다.

   객체 참조는 줄여서 객체간의 결합도는 낮추고, 로직의 결합도를 높이고 싶다.

2. 도메인 이벤트(Domain Event) 사용

   로직간의 A가 끝났을 때, B, C가 실행되었으면 좋겠어, 근데, 최대한 이 순서를 느슨하게 만들고 싶어.

   그래서, 이벤트를 발행해서 누군간 받아주겠지 라고 생각한다.

### 이게 정말 잘 된걸까?

이를 검증하는 방법은 그려서 확인하는 법이다.

그려보면 의존성 역전을 적용할 부분이 보일 수도 있다.

패키지 간의 의존성 사이클이 돌 때, 추상화를 적용한다.

1. 좀 더 추상적인 중간 객체를 만들고 이것으로 변환하는 로직을 사용한다.

2. 인터페이스를 만들고 이를 구현하는 것으로 변경한다.

3. 패키지를 분리해버린다.

   패키지를 분리하면 얻는 이점은 도메인 로직이 확실히 분리가 됨.

### 이 영상에서 전달하고픈 점

의존성을 보면서 내가 뭘 봐야 되는지를 쫓아가면 좋겠다.

### 정리(패키지 의존성 사이크를 제거하는 3가지 방법)

1. 중간 객체 만들기(새로운 객체로 변환)

   ![1st](https://i.imgur.com/0cFqvpr.png)

2. 의존성을 인터페이스나 추상 클래스를 통해서 의존성 역전

   ![2nd](https://i.imgur.com/IzNGWOM.png)

3. 새로운 패키지 추가

   ![3rd](https://i.imgur.com/zLkTUAH.png)

3가지 중 어떤 것을 고를 것이냐는 판단에 따라 다름(Trade-off 가 필요)

### 의존성과 시스템 분리

도메인과 서비스로 분리하는 기술적인 레이어 단위로 패키지를 쪼갰었음.

왜냐하면 도메인으로 분리하면 의존성 사이클이 존재하기 때문임.

그리고 이렇게 하는 편이 관리하기도 편함.(왜냐하면 별 다른 신경을 안써도 그 안에서 돌기 때문임)

하지만, 도메인 이벤트를 사용해서 도메인 단위를 분리하게 된다면, 의존성 사이클이 제거됨.

![systemseperation](https://i.imgur.com/j9LjvYa.png)

각각은 도메인 이벤트를 통해서 협력을 하게됨.

이렇게 분리한다면, 시스템을 분리하기 쉬워짐. (Domain과 Service 패키지로 묶여있을 때보다 쉬워짐)

![systemsep](https://i.imgur.com/vIPFKeF.png)

배민은 이런식으로 분리를 해서 시스템끼리 비동기적인 메시지 통신으로 커뮤니케이션은 함. (트래픽이 많아서 연쇄적으로 죽어서)

시스템을 쪼갤 때 무턱대고 쪼개지 말고 의존성을 확인한 다음에 의존성 사이클을 분리하는 기법을 통해 분리하고 쪼개자

어떤 타이밍에 어떻게 쪼개야 할 지 고민하자.

**의존성에 따라 시스템을 진화시켜라**

## 생활코딩 OAuth2.0

OAuth는 여러가지 Application 기술들을 이용해서 구현되는 기술임.

OAuth과 관련해서 세 개의 참여자가 있는데 각각이 누구인지 살펴보기

1. 나의 서비스
2. 나의 서비스를 사용하는 사용자
3. 나의 서비스가 연동하려는 그들의 서비스

### 우리가 하려고 하는 것

사용자가 우리 서비스에 접속해서 무엇인가 하고, 나의 서비스가 사용자를 대신해서 그들의 서비스에 기록하거나 공유하는 것

### 우리가 필요한 것

사용자로부터 사용자가 사용하고 있는 그들의 서비스에 접속할 수 있도록 허가를 받는 것

#### 가장 쉬운 방법은 그들의 서비스의 ID와 Password를 받아서 기억하고 있고, 그들의 서비스에 접속할 때, 이를 이용하는 것

- 아주 강력하지만, 상당히 위험하고 걱정되는 방법임.
- 아주 큰 보안 사고가 일어날 수 있음.
- 이것이 유실되었을 때, 우리가 겪게될 고초는 상상도 할 수 없음.
- 그들의 서비스에서도 신뢰할 수 없는 사이트에 넘긴다는 것은 굉장히 불안함.

#### 이를 해결하고자 OAuth가 등장함.

훨씬 더 안전하게 우리가 만든 서비스를 그들의 서비스와 연동할 수 있게 됨.

### OAuth를 이용하면 생기는 변화

ID, Password 대신에 accessToken을 우리 서비스에게 발급함.(일종의 비밀번호)

1. 그들의 서비스의 ID, Password가 아니라는 장점
2. 나의 서비스가 필요한 필수적인 부분만 허용하는 비밀번호임.

OAuth를 통해서 얻어낼 수 있는 것, **AccessToken**

이를 이용하면, 회원들의 ID, Password를 저장하지 않고, 회원을 식별할 수 있는 기능을 구현할 수 있음.

우리는 OAuth를 이용해서 AccessToken을 얻어내는 원리를 탐험할 것임.

### 역할

1. 우리의 서비스: mine ⇒ Client
2. 우리의 사용자: User ⇒ Resource Owner
3. 그들의 서비스: their ⇒ Resource Server

Resource(자원)에 대한 것.

3자간의 관계가 OAuth의 핵심

#### Resource Server와 Authorization Server의 차이

Resource Server: Data를 가지고 있는 서버

Authorization Server: 인증과 관련된 처리를 전담하는 서버

공식문서에서는 구분하지만, 우리의 강의에서는 하나로 합쳐서 생각함.

