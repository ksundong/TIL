# 자바 데이터 타입, 변수 그리고 배열

## 학습할 것

- [프리미티브 타입 종류와 값의 범위 그리고 기본 값](#프리미티브-타입-종류와-값의-범위-그리고-기본-값)
- [프리미티브 타입과 레퍼런스 타입](#프리미티브-타입과-레퍼런스-타입)
- [리터럴](#리터럴)
- [변수 선언 및 초기화하는 방법](#변수-선언-및-초기화하는-방법)
- [변수의 스코프와 라이프타임](#변수의-스코프와-라이프타임)
- [타입 변환, 캐스팅 그리고 타입 프로모션](#타입-변환,-캐스팅-그리고-타입-프로모션)
- [1차 및 2차 배열 선언하기](#1차-및-2차-배열-선언하기)
- [타입 추론, var](#타입-추론,-var)

## 프리미티브 타입 종류와 값의 범위 그리고 기본 값

primitive type은 자바의 기본 타입들입니다. 총 8개 입니다.

자바에서는 필드 선언시 초기화를 하지 않으면, 기본 값으로 초기화가 됩니다. 프리미티브 타입은 유의미한 값을 가지며, 레퍼런스 타입은 null로 초기화가 됩니다.

- **boolean**: **참(true)** 혹은 **거짓(false)**를 나타내는 boolean 타입입니다. 1bit로도 표현가능하지만, 일반적인 JVM의 구현은 1byte를 사용하는 것으로 알려져있습니다. (크기는 JVM의 구현에 의존적입니다.) 기본 값은 `false`입니다.
- **char**: **유니코드 문자**를 나타내는 정수형 타입입니다. 특이점으로는 unsigned 2byte기 때문에 표현할 수 있는 값의 범위는 '\u0000'(0)에서 '\uffff'(65535) 입니다. 기본 값은 `'\u0000'`입니다.
- **byte**: 이름과 같이 1byte를 차지하는 정수형 타입입니다. -128 ~ 127의 범위를 가집니다. 기본 값은 `0`입니다.
- **short**: 2byte를 차지하는 정수형 타입입니다. -32,768 ~ 32,767의 범위를 가집니다. 기본 값은 `0`입니다.
- **int**: 4byte를 차지하는 정수형의 타입입니다. -2<sup>31</sup> ~ 2<sup>31</sup>-1 의 범위를 가집니다. 기본 값은 `0`입니다. 또, 리터럴로 정수형 값을 할당할 때, 기본적으로 사용되는 타입입니다.
- **long**: 8byte를 차지하는 정수형 타입입니다. -2<sup>63</sup> ~ 2<sup>63</sup>-1의 범위를 가집니다. 정수형 리터럴에 `L`이나 `l`을 뒤에 붙이면 long 타입으로 생성되며, 일반적으로 대문자 L이 혼동을 방지할 수 있어 (소문자 l의 경우엔 유사한 문자가 많아서) **대문자를 사용하는 것이 일반적**입니다. 기본 값은 `0`입니다.
- **float**: 4byte를 차지하는 IEEE 754 단정밀도 부동소수점 타입입니다. 부동소수점 타입은 표현가능한 값의 범위는 굉장히 넓으나, 정확히 표현하지 못하는 한계가 있기 때문에 보통은 **유효 숫자 범위**를 더 중요하게 생각합니다. float 타입은 **6~7 자리의 정밀도**를 가집니다. 부동소수점 리터럴에 `f`혹은 `F`를 붙여서 표현합니다. 기본값은 `0.0f`입니다.
- **double**: 8byte를 차지하는 IEEE 754 배정밀도 부동소수점 타입입니다. double 타입은 **15자리의 정밀도**를 가집니다. 부동소수점 리터럴은 기본적으로 double 형을 사용하나 `d`혹은 `D`를 사용해서 표현할 수도 있습니다. 기본값은 `0.0d`입니다.

부동소수점은 [IEEE 754 Wikipedia](https://ko.wikipedia.org/wiki/IEEE_754) 여기에 자세히 설명되어 있으며, 부동소수점이 어떻게 구성되어 있는지 설명하는 것은 별개의 범위인 것 같아 여기까지 하겠습니다.

부동소수점은 정밀도가 있다고는 하지만 값의 정확한 연산을 보장하지 못하므로 화폐 계산과 같은 연산을 할 때에는 `BigDecimal` 클래스를 사용하는 것이 좋습니다.

### 표

| type    | size in bytes                   | range                                | default value |
| ------- | ------------------------------- | ------------------------------------ | ------------- |
| boolean | 정의되지 않음(일반적으로 1byte) | true or false                        | false         |
| char    | unsigned 2byte                  | '\u0000'(0) to '\uffff'(65535)       | '\u0000'      |
| byte    | 1byte                           | -128 to 127                          | 0             |
| short   | 2byte                           | -32,768 to 32,767                    | 0             |
| int     | 4byte                           | -2<sup>31</sup> to -2<sup>31</sup>-1 | 0             |
| long    | 8byte                           | -2<sup>63</sup> to -2<sup>63</sup>-1 | 0             |
| float   | 4byte                           | (6~7자리 정밀도)                     | 0.0f          |
| double  | 8byte                           | (15자리 정밀도)                      | 0.0d          |

### 참고

[오라클 자바 튜토리얼, 데이터 타입](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)

[cs-fundamentals](https://cs-fundamentals.com/java-programming/java-primitive-data-types)

[Oracle JLS 4. Types, Values, and Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html)

---

[학습할 것으로](#학습할-것)

## 프리미티브 타입과 레퍼런스 타입

자바의 타입은 크게 두 종류로 나눌 수 있습니다. primitive type과 reference type입니다.

primitive type은 위에서 설명했고, reference type에 대해서 설명하겠습니다.

reference type은 primitive type을 제외한 모든 타입들이 해당됩니다. 이런 reference type은 변수 선언시 변수에 값이 저장되는 것이 아니라 객체에 대한 힙 영역의 참조를 저장하게 됩니다. 자바의 참조는 포인터가 아니기 때문에, 개발자는 직접적으로 메모리에 접근해서 조작할 수 없습니다.

이 참조를 저장한다는 말은, 같은 참조를 가리키고 있다면 한 쪽에서 객체의 상태를 변경하는 경우 다른 쪽에서도 영향을 받을 수 있다는 것입니다.

아래의 코드는 그러한 사항을 간단히 확인해보는 코드입니다.

```java
void 상태변경() {
    // 새로운 Hello type 인스턴스를 생성해서 a라는 변수에 참조를 저장하고,
    // b라는 변수에 a가 가지고 있는 참조를 할당했습니다.
    Hello a = new Hello();
    Hello b = a;

    // a, b 둘 다 새로 만든 Hello 인스턴스에 대한 참조를 가지고 있는 상태입니다.
    // 이 때, b를 통해서 상태를 조작할 경우 a에서도 영향을 받게됩니다.
    // property는 초기화시 0으로 초기화 되었다고 가정합니다.
    a.showProperty(); // 0
    b.showProperty(); // 0
    b.changeProperty(999);
    b.showProperty(); // 999
    a.showProperty(); // 999로 변경된 상태를 표시합니다.
}
```

또, reference type에는 특별한 타입인 `null`을 할당할 수 있지만, primitive type에는 할당할 수 없습니다. `null`의 의미가 null 참조를 의미하기 때문입니다. 공부를 하면서 든 생각인데, null 참조라고 하면서 Exception의 이름은 `NullPointerException` 이라는게 좀 신기하게 느껴졌습니다. 큰 의미를 두고 생각하진 않았습니다.

특이한 것은 reference type의 구분을 `Class`, `Interface`, `Type Variable`(흔히 `Generic`이라고 말하는), `Array` 로 구분한다는 점입니다.

### 참고

[Geeks for Geeks - C/C++의 포인터와 자바의 참조의 차이](https://www.geeksforgeeks.org/is-there-any-concept-of-pointers-in-java/)

[Oracle JLS 4. Types, Values, and Variables](https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html)

---

[학습할 것으로](#학습할-것)

## 리터럴

리터럴은 고정된 값을 나타내는 소스코드상에서의 표현입니다. 리터럴은 별도의 연산이 필요없이 표현됩니다.

### 정수 리터럴

정수 리터럴은 정수형 숫자, 정수형 숫자가 L 또는 l로 끝나는 형태로 표현됩니다. `byte`, `short`, `int`, `long` 타입은 `int` 리터럴로 생성될 수 있습니다. `int` 범위를 벗어나는 값은 `long` 리터럴로 생성됩니다.

```java
void 정수_리터럴() {
    byte byteVal = 1;
    short shortVal = 1;
    int intVal = 1;
    long longVal = 1;
}
```

정수 리터럴은 10진법을 기본으로, 16진법, 2진법으로도 표현될 수 있습니다.

- 10진법: 0부터 9로 구성되는 일반적으로 사용하는 숫자체계입니다.
- 16진법: 0부터 9, A부터 F로 구성된 16진수입니다. 16진법을 많이 사용하는 이유는 2<sup>4</sup>를 한 자리에서 표현이 가능하기 때문입니다.
- 2진법: Java 7 이상부터 작성할 수 있는 리터럴로 0과 1로 구성되는 숫자체계입니다.

```java
void 진법별_26_표현() {
    int decVal = 26;
    int hexVal = 0x1a;
    int binVal = 0b11010;
}
```

### 부동 소수점 리터럴

부동 소수점 리터럴은 소숫점이 포함된 숫자가 F또는 f로 끝나는 형태로 표현됩니다. 이 경우엔 `float` 형 리터럴이고, 나머지 경우와 D또는 d로 끝나는 경우엔 `double` 형 리터럴입니다.

부동 소수점은 E또는 e를 사용해서 지수 표현식으로도 작성할 수 있습니다.

```java
void 지수_표기법() {
    double d1 = 123.4;
    // 지수 표기법으로는 다음과 같습니다.
    double d2 = 1.234e2;
}
```

### 숫자 리터럴에서의 밑줄 문자사용

자바7부터 추가된 기능으로, 숫자 리터럴을 읽기 쉽게해줍니다. 자릿수가 긴 리터럴을 표현할 때 유용합니다.

숫자 사이에만 밑줄을 넣을 수 있고, 다음 위치에는 넣을 수 없습니다. 연속으로 입력도 가능합니다.

- 숫자의 시작 또는 끝
- 부동 소수점 리터럴에서 소수점에 붙은경우
- 뒤에 붙는 F, L, D등의 문자의 앞 뒤에 붙은경우
- 문자열에서 문자가 올 것으로 예상되는 위치

```java
void 밑줄_사용한_숫자_표현() {
    long phoneNumber = 010_1234_5678;
    long bigNumber = 999_999_999_999_999_999L;
    long manyUnderScore = 9________9;
}
```

### 문자 및 문자열 리터럴

`char`와 `String` 은 유니코드로 표현됩니다. 직접 해당 문자를 코드에 입력할 수도 있고, 유니코드 이스케이프('\u0000')를 사용할 수 있습니다.

`char` 형 리터럴은 작은 따옴표(')를 사용하고, `String` 형 리터럴은 큰 따옴표(")를 사용합니다.

그리고 Java는 몇 가지 특별한 문자를 가지고 있고, 이를 이스케이프 문자라고 합니다. `\`를 이스케이프 문자라고 하며 백슬래시를 입력해서 사용할 수 있습니다.  
`\b`(백 스페이스), `\t`(탭), `\n`(라인 피드), `\f`(폼 피드), `\r`(캐리지 리턴), `\"`, `\'`, `\\`

### 불린 리터럴

불린 리터럴은 논리값을 나타내는 표현입니다. `true`, `false`로 나타낼 수 있습니다.

### 그 외 리터럴

`null` 도 리터럴이며 특수 리터럴로 분류됩니다.

`Class` 리터럴이라는 특수한 리터럴도 존재합니다. 이는 `<type의 이름>.class`의 형태로 표현합니다. 이는 `Class` 타입 자체를 나타내는 객체의 참조를 반환하며, reflection을 사용할 때, 많이 이용합니다.

### 참조

[오라클 자바 튜토리얼, 데이터 타입](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)

---

[학습할 것으로](#학습할-것)

## 변수 선언 및 초기화하는 방법

자바의 변수는 다음과 같은 종류로 구분할 수 있습니다.

- 인스턴스 변수: 클래스 선언시 `static` 키워드 없이 선언된 필드입니다. 이 필드는 인스턴스 별로 다른 값을 가질 수 있기 떄문에, 인스턴스 변수라고 불립니다.
- 클래스 변수: 클래스 선언시 `static` 키워드와 함께 선언된 필드입니다. 이 필드는 모든 인스턴스들이 공유하는 값입니다. 클래스 명으로 접근이 가능하고, 클래스 하나에 한 값이기 때문에 클래스 변수라고 불립니다.
- 로컬 변수: 메서드 선언 사이에 등장하는 변수로 다른 클래스에서 접근할 수 없는 변수입니다. 메서드 영역에서만 임시로 사용되는 변수입니다.
- 매개 변수: 매개 변수는 메서드의 인자로 전달되는 변수를 의미합니다.

인스턴스 변수와 클래스 변수는 멤버 변수라고 통칭하기도 합니다. 멤버 변수는 꼭 초기화를 해주지 않더라도 기본값으로 초기화되지만, 로컬 변수는 반드시 초기화를 해주어야 합니다.

```java
class Variables {
    int instanceVar; // 0으로 초기화되는 인스턴스 변수
    static int classVar; // 0으로 초기화되는 클래스 변수
    int initInstanceVar = 10; // 명시적으로 초기화
    static int initClassVar = 10; // 명시적으로 초기화

    void method(int num) { // 매개변수는 초기화 할 수 없고, 전달받는 값을 사용만 할 수 있음
      int a; // 선언은 가능
      // int b = a; 자동으로 초기화 되지 않으므로 동작하지 않음
      a = 10; // 선언을 미리 해줬다면 이렇게 초기화 가능
      int b = a; // 선언과 동시에 초기화
    }
}
```

### 참조

[오라클 자바 튜토리얼, 변수](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html)

---

[학습할 것으로](#학습할-것)

## 변수의 스코프와 라이프타임

스코프란? 변수가 유효한 범위를 의미합니다. 의도하신 부분이 코드에서의 스코프를 의미하신 것 같습니다. (자바는 추가로 Access modifier에 의한 스코프도 추가로 정의됩니다.)

| Variable Type     | Scope                                                  | LIfetime                                      |
| ----------------- | ------------------------------------------------------ | --------------------------------------------- |
| Instance Variable | (`static` 블록과 `static` 메서드를 제외한) 클래스 전체 | 객체가 생성되고 객체가 메모리에 살아있는 동안 |
| Class Variable    | 클래스 전체                                            | 클래스가 초기화되고 프로그램이 끝날 때 까지   |
| Local Variable    | 변수가 선언된 블록내부                                 | 변수 선언 이후 부터 블록을 벗어날 때까지      |

### 참고

<https://www.learningjournal.guru/article/programming-in-java/scope-and-lifetime-of-a-variable/>

---

[학습할 것으로](#학습할-것)

## 타입 변환, 캐스팅 그리고 타입 프로모션

[학습할 것으로](#학습할-것)

## 1차 및 2차 배열 선언하기

[학습할 것으로](#학습할-것)

## 타입 추론, var

[학습할 것으로](#학습할-것)
