# 8주차 과제: 인터페이스

## 학습할 것

- [8주차 과제: 인터페이스](#8주차-과제-인터페이스)
- [인터페이스 정의하는 방법](#인터페이스-정의하는-방법)
- [인터페이스 구현하는 방법](#인터페이스-구현하는-방법)
- [인터페이스 레퍼런스를 통해 구현체를 사용하는 방법](#인터페이스-레퍼런스를-통해-구현체를-사용하는-방법)
- [인터페이스 상속](#인터페이스-상속)
- [인터페이스의 기본 메소드(Default Method), 자바 8](#인터페이스의-기본-메소드default-method-자바-8)
- [인터페이스의 static 메소드, 자바 8](#인터페이스의-static-메소드-자바-8)
- [인터페이스의 private 메소드, 자바 9](#인터페이스의-private-메소드-자바-9)

## 인터페이스 정의하는 방법

일반적으로 소프트웨어 개발에서 "약속"은 프로그래머들의 소프트웨어간의 소통에 있어서 중요합니다. 각각의 소프트웨어는 다른 소프트웨어의 구체적인 지식이 없이도 코드를 작성할 수 있어야합니다. 인터페이스는 이를 가능하게 해주는 자바의 방법 중 하나입니다.

인터페이스는 우리가 흔히 말하는 UI, API 등에 들어가는 Interface와 동일한 의미입니다. 인터페이스를 사용하는 이유는, **구체적인 내용에 대한 지식**이 없이도 **어떻게 동작할지에 대한 약속을 지킨다고 생각하고 사용할 수 있다**는 점에 있습니다.

### 자바의 인터페이스

자바에서 인터페이스는 클래스와 유사한 형태를 띄는 참조타입이고, 가지고 있을 수 있는 멤버가 한정되어 있습니다. (상수, 메서드 시그니처, default 메서드, static 메서드, 중첩 타입) 인터페이스는 인스턴스화 할 수 없으며, 클래스에서 구현하거나 다른 인터페이스에서 인터페이스를 상속할 수 있습니다.

인터페이스를 정의하는 것은 클래스 정의와 비슷합니다.

```java
public interface Car {

  // 상수 정의(가급적이면 사용하는 것을 권장 X, Effective Java 참조)

  // 메서드 시그니처 정의
  boolean drive();

  // 열거형 값 정의

  // 기타 default 메서드, static 메서드, 중첩 타입 정의
}
```

메서드 시그니처는 중괄호를 입력하지 않고 세미콜론으로 끝냅니다.

인터페이스를 사용하기 위해서는 인터페이스를 `implements`하는 클래스를 작성해야 합니다.

### 참고

- [오라클 자바 튜토리얼(인터페이스)](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)

## 인터페이스 구현하는 방법

인터페이스를 구현하는 방법은 다음과 같습니다.

```java
public class ToyCar implements Car {

  @Override // 컴파일러에서 재정의 관련 문제를 예방하기 위해서 꼭 붙입니다.
  public boolean drive() {
    System.out.println("장난감 자동차가 움직입니다.");
    return true;
  }

  public void play() {
    if (this.drive()) {
      System.out.println("장난감 자동차가 잘 움직였네요.");
    }
  }

  // 추가로 정의된 멤버, 메서드 구현
  // 인터페이스에 정의되지 않은 것은 인터페이스를 통해서는 확인할 수 없습니다.
}
```

우리가 만든 이 인터페이스는 API로도 사용될 수 있습니다. 일반적으로 우리 내부의 인터페이스를 제외한 외부에서 제공된 인터페이스를 API라고 생각하면 됩니다.  
우리가 API들을 사용할 때, 내부 동작에는 신경쓰지 않고 어떻게 동작할지에 대한 약속만 신뢰하는 것과 동일하다고 보면 됩니다.

## 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

인터페이스는 인스턴스화가 불가능합니다. 그렇다면 어떻게 사용해야 할까요?

인터페이스를 구현한 클래스를 인스턴스화해서 사용할 수 있습니다.

```java
public static void main(String[] args) {
  Car car = new ToyCar();

  car.drive(); // 이건 됩니다.
  car.play(); // 이건 안됩니다.
}
```

위 코드는 컴파일 되지 않습니다. 왜일까요? `play`라는 메서드는 `ToyCar`에 분명히 정의되어 있습니다. 하지만 `Car`에서는 해당 메서드에 대해서 모르고 있는 상태입니다.

따라서, 해당 코드는 `play` 메서드를 호출하는 부분을 제거해야 컴파일 됩니다.

```java
public static void main(String[] args) {
  Car car = new ToyCar();

  car.drive(); // 이건 됩니다.
}
```

이렇게 된다면 장점은 바로, `ToyCar`를 다른 것으로 대체해도 인터페이스의 약속만 지킨다면 코드의 동작에 문제가 없다고 추측할 수 있다는 것입니다.  
다시말해 변경에 유연해집니다.

이것이 바로 추상화가 가져다 주는 변경에 유연해지는 코드입니다.

실제 인스턴스는 `ToyCar`의 인스턴스기 때문에 다음과 같이 사용이 가능합니다.

```java
public static void main(String[] args) {
  Car car = new ToyCar();

  car.drive(); // 이건 됩니다.
  ((ToyCar) car).play(); // 이건 됩니다.
}
```

## 인터페이스 상속

### 인터페이스 상속과 클래스 상속

## 인터페이스의 기본 메소드(Default Method), 자바 8

## 인터페이스의 static 메소드, 자바 8

## 인터페이스의 private 메소드, 자바 9
