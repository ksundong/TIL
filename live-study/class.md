# 5주차: 클래스

## 학습할 것

- [클래스 정의하는 방법](#클래스-정의하는-방법)
- [객체 만드는 방법 (new 키워드 이해하기)](#객체-만드는-방법-new-키워드-이해하기)
- [메소드 정의하는 방법](#메소드-정의하는-방법)
- [생성자 정의하는 방법](#생성자-정의하는-방법)
- [this 키워드 이해하기](#this-키워드-이해하기)

## 과제(선택)

- [int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.](#int-값을-가지고-있는-이진-트리를-나타내는-node-라는-클래스를-정의하세요)
- [int value, Node left, right를 가지고 있어야 합니다.](#int-value-node-left-right를-가지고-있어야-합니다)
- [BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.](#binraytree라는-클래스를-정의하고-주어진-노드를-기준으로-출력하는-bfsnode-node와-dfsnode-node-메소드를-구현하세요)
- [DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.](#dfs는-왼쪽-루트-오른쪽-순으로-순회하세요)

## 클래스 정의하는 방법

객체지향 프로그래밍(OOP)에서 가장 기본이 되는 Class는 다음과 같이 정의할 수 있습니다.

클래스는 필드를 선언할 수 있고, 생성자를 가져야 하며, 메서드를 선언할 수 있습니다.

```java
public class Bicycle {

  // Bicycle 클래스는 3개의 필드를 가지고 있습니다.
  // 클래스에 선언된 필드와 함수들을 통틀어 멤버라고 합니다.
  // 아래의 필드는 멤버 변수라고도 부르고, 속성(property)이라고도 합니다,
  // 일반적으로 객체지향 프로그래밍을 할 때는 private 접근제어자로 속성을 감춥니다.
  public int cadence;
  public int gear;
  public int speed;

  // 다음은 생성자라고 불리는 문법입니다.
  // 생성자는 특수한 형태로, 인스턴스를 초기화 할 때 사용하는 문법입니다.
  // 생성자가 만약 존재하지 않는다면 기본 생성자(매개변수를 받지 않는)가 생성됩니다.
  // 생성자는 클래스와 이름이 같아야 합니다.
  // this 키워드는 생성되는 인스턴스를 가리킵니다. (혼란을 방지하기 위해 사용합니다.)
  public Bicycle(int startCadence, int startSpeed, int startGear) {
    this.cadence = startCadence;
    this.speed = startSpeed;
    this.gear = startGear;
  }

  // Bicycle 클래스는 4개의 메서드를 가집니다.
  public void setCadence(int newValue) {
    this.cadence = newValue;
  }

  public void setGear(int newValue) {
    this.gear = newValue;
  }

  public void applyBrake(int decrement) {
    this.speed -= decrement;
  }

  public void speedUp(int increment) {
    this.speed += increment;
  }
}
```

이 코드의 마지막 메서드 두 개는 객체지향적이라고 볼 수 있습니다. 외부에서 setter로 속도를 조절하는 것이 아니라, 객체가 직접 자신의 속성을 의미있게 변경하도록 했기 때문입니다.

이런 식의 코드를 지향한다면, 보다 읽기좋고, 변화에 유연한 코드를 작성할 수 있습니다.

---

클래스의 선언에는 필드, 생성자, 메서드 정의가 포함될 수 있습니다. 각각의 용도는 다음과 같습니다.

- 필드: 인스턴스 필드에 한하여, 각 인스턴스의 속성을 나타냅니다. 클래스 필드의 경우에는 클래스 레벨에서의 속성을 나타냅니다.
- 생성자: 새로운 객체를 생성하는 용도입니다.
- 메서드: 클래스와 그 객체의 행동을 구현하는 용도입니다.

그 밖에도 부모 클래스를 상속하는 지의 여부나, 인터페이스를 구현하는 지의 여부 등을 클래스 선언 시작지점에 정의합니다.

```java
class MyClass extends MySuperClass implements YourInterface {
  // field, constructor, and
  // method 정의
}
```

위 클래스 `MyClass`는 `MySuperClass`의 서브클래스이며, `YourInterface`를 구현함을 의미하는 코드입니다.

또한 접근 제어자(`public`, `private`)를 맨 앞에 추가할 수도 있으므로 클래스 선언부는 복잡해질 수 있습니다.  
두 접근 제어자는 다른 클래스가 `MyClass`에 접근할 수 있는지를 결정합니다.

클래스 선언에 포함될 수 있는 요소들입니다.

1. `public`, `private` 등의 제어자들
2. 첫글자가 대문자인 클래스 명
3. 부모 클래스가 있는 경우 `extends` 키워드 다음에 부모 클래스의 이름을 붙입니다. 클래스는 **단 하나의** 상위 클래스만 상속할 수 있습니다. 자바는 다중상속을 지원하지 않습니다.
4. `implements` 키워드 뒤에 인터페이스들의 목록이 올 수 있습니다. 클래스는 **여러** 인터페이스를 동시에 구현할 수 있습니다.
5. 중괄호로 클래스 본문(body)을 선언합니다.

### 참고

- [오라클 자바 튜토리얼(클래스)](https://docs.oracle.com/javase/tutorial/java/javaOO/classes.html)
- [오라클 자바 튜토리얼(클래스 선언)](https://docs.oracle.com/javase/tutorial/java/javaOO/classdecl.html)
- [생성자와 메서드의 차이](https://www.tutorialspoint.com/Difference-between-constructor-and-method-in-Java)

## 객체 만드는 방법 (new 키워드 이해하기)

일반적으로 클래스는 객체의 청사진이라고 합니다. 이 의미는 무슨 뜻일까요?

한 클래스를 가지고 해당 클래스의 인스턴스 여러개를 만들 수 있습니다. 클래스에 정의된 필드나 메서드 정보는 인스턴스 생성시마다 다른 장소에 저장됩니다.

그렇다면 어떻게 해야 이 인스턴스를 만들어낼 수 있을까요? 위에서 말한 생성자는 어떻게 해야 이용할 수 있을까요?

```java
Point originOne = new Point(23, 94);
Rectangle rectOne = new Rectangle(originOne, 100, 200);
Rectangle rectTwo = new Rectangle(50, 100);
```

위의 코드가 바로 생성자를 이용해서 객체를 만들어내는 코드라고 볼 수 있습니다. 새로운 객체를 생성할 때에는 `new` 키워드를 붙여주어야 하며, 이 때 사용하는 것이 생성자고, 이를 초기화한다고 합니다.

즉, 위의 구문은 다음의 세 가지 순서로 진행됩니다.

1. 선언: 먼저 컴파일러에게 내가 해당 타입의 객체를 사용할 것이라고 알려줍니다.
2. 인스턴스화: `new` 키워드로 컴파일러에게 해당 타입의 인스턴스를 생성할 것임을 알려줍니다.
3. 초기화: `new` 키워드 다음에 생성자 호출이 이루어지면서, 객체를 초기화합니다.

### 객체 변수 선언

우리는 컴파일러에게 우리가 사용할 객체 타입을 알려주고, 이에 대한 변수를 선언할 수 있습니다.

```java
Type name;
```

위와같은 방식으로 변수를 선언할 수 있습니다. 이렇게 컴파일러에게 알려주면, 컴파일러는 `name`이라는 변수는 `Type`이라는 타입을 저장할 공간과 이에 대한 참조값을 저장할 공간을 할당합니다. 기본 타입을 사용하면 그에 맞는 적절한 메모리를 할당하며, 기본 타입 이외의 타입을 사용할 경우 참조 값을 저장할 공간만 할당됩니다.

꼭 선언과 동시에 초기화 할 필요는 없으며, 적절한 위치에 선언하고 초기화 하는 방식도 종종 사용됩니다.

하지만 초기화 되기 전에 사용된다면, 멤버 변수인 경우엔 기본값으로 초기화 되어서 괜찮을 수 있지만, 메서드 내부나 지역 변수인 경우엔 컴파일 에러가 발생하게 됩니다.

이런 상태를 참조하는 것이 없는 상태라고 합니다.

### 클래스 인스턴스화

`new` 연산자는 새로운 객체를 위한 메모리를 할당하고, 그 메모리에 대한 참조를 반환하는 연산자입니다. `new` 연산자는 피연산자로 객체의 생성자를 사용합니다.

> 참고: 클래스 인스턴스화는 객체 생성과 동일한 의미입니다. 객체를 생성할 때, 클래스에 대한 인스턴스를 만드는 것이고 이를 클래스를 인스턴스화 한다고 합니다.

`new` 연산자는 연산자 뒤에 피연산자로 생성자를 받으며, 생성자의 이름은 인스턴스화 할 클래스의 이름을 제공하면 됩니다.

`new` 연산자는 만든 객체의 참조를 반환하며, 일반적으로 생성자와 맞는 적절한 타입의 변수에 할당됩니다.

꼭 `new` 연산자의 참조를 변수에 저장할 필요는 없습니다.

```java
int height = new Rectangle().height;
```

### 객체 초기화

초기화는 생성자에서 이루어지며, 생성자에서 기본값을 줄 수도 있고, 파라미터로 받아서 할당할 수도 있습니다. 생성자는 여러개 선언될 수 있으며, 이 때 생성자의 시그니처는 달라야 합니다.  
자바의 경우에는 파라미터의 수, 타입에 따라 시그니처를 구분할 수 있습니다.

생성자에서 코드가 실행되면 객체가 초기화되고, 이렇게 초기화된 객체의 참조가 반환되게 됩니다.

모든 클래스는 하나 이상의 생성자가 있어야 합니다. 따라서 아무 생성자도 선언하지 않았더라도, 컴파일 과정에서 컴파일러가 기본 생성자를 추가해줍니다. 기본 생성자는 인자가 없는 생성자를 의미합니다.  
클래스에게 다른 부모 클래스가 없다면 `Object`의 생성자가 사용됩니다. 만약 부모가 생성자가 없다면, 컴파일러는 프로그램의 실행을 거부할 것입니다.

해당 부분이 궁금해서 [스택오버플로우](https://stackoverflow.com/a/47883266/9748089)에서 찾아보았습니다.

신기하네요!

### 참고

- [오라클 자바 튜토리얼(객체 생성)](https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html)

## 메소드 정의하는 방법

## 생성자 정의하는 방법

## this 키워드 이해하기

## int 값을 가지고 있는 이진 트리를 나타내는 Node 라는 클래스를 정의하세요.

## int value, Node left, right를 가지고 있어야 합니다.

## BinrayTree라는 클래스를 정의하고 주어진 노드를 기준으로 출력하는 bfs(Node node)와 dfs(Node node) 메소드를 구현하세요.

## DFS는 왼쪽, 루트, 오른쪽 순으로 순회하세요.
