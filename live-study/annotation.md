# 12주차: 애노테이션

## 학습할 것

- [애노테이션이란?](#애노테이션이란?)
- [애노테이션 정의하는 방법](#애노테이션-정의하는-방법)
- [`@retention`](#retention)
- [`@target`](#target)
- [`@documented`](#documented)
- [애노테이션 프로세서](#애노테이션-프로세서)

## 애노테이션이란?

애노테이션은 프로그램의 소스코드에 다른 프로그램을 위해서 정보를 사전에 약속된 형식으로 표현한 것을 의미합니다. 애노테이션은 프로그램의 실행에는 별 다른 영향을 미치지 않고, 다른 프로그램에 유용한 정보를 제공할 수 있습니다.

이러한 애노테이션은 정보를 제공받을 프로그램에서 지정한 종류와 형식을 따라야만 의미가 있습니다.  
애너테이션은 JDK에서 기본적으로 제공되는 애노테이션과 특정 프로그램에서 제공하는 애노테이션이 있습니다. 

JDK 에서 제공하는 애노테이션은 주로 컴파일러를 위한 것이고, 새로운 애노테이션을 정의할 때 사용하는 메타 애노테이션 또한 제공합니다.

### 표준 애노테이션

| 애노테이션             | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `@Override`            | 컴파일러에게 오버라이딩 되는 메서드임을 알려줍니다.          |
| `@Deprecated`          | 기존의 것을 함부로 삭제하기 어려우므로, 이 코드는 다른 것으로 대체되었으므로 사용하지 않는 것을 권장함을 알려줍니다. |
| `@SuppressWarnings`    | 경고의 대상을 억제합니다.<br />- "deprecation": `@Deprecated` 된 대상 사용시 발생하는 경고 억제 <br />- "unchecked": 제네릭 타입을 지정하지 않았을 때 발생하는 경고 무시<br />- "rawtypes": 로(raw) 타입을 사용해서 발생하는 경고 무시<br />- "varargs": 가변인자의 타입이 제네릭인 경우 발생하는 경고 무시(가변인자는 배열로 변환됩니다.)<br />대괄호로 여러개 지정할 수도 있습니다. |
| `@SafeVarargs`         | 메서드에 선언된 가변인자의 타입이 *non-reifiable* 타입인 경우 해당 메서드를 사용하는 코드에서 "uncheked" 경고가 발생하는데 이를 무시합니다.(JDK1.7) |
| `@FunctionalInterface` | 함수형 인터페이스를 선언할 때, 컴파일러가 이 인터페이스가 함수형 인터페이스로 선언가능한지 체크해줍니다.(추상메서드가 하나만 존재해야 한다는 제약)(JDK1.8) |
| `@Native`              | native 메서드에서 참조되는 상수 앞에 붙입니다. (JDK1.8)      |
| **`@Target`**          | 애노테이션이 적용가능한 대상을 지정하는데 사용합니다.        |
| **`@Documented`**      | 애노테이션 정보가 javadoc으로 작성된 문서에 포함되도록 합니다. |
| **`@Inherited`**       | 애노테이션이 자손 클래스에 상속되도록 합니다.                |
| **`@Retention`**       | 애노테이션이 유지되는 범위를 지정하는데 사용합니다.          |
| **`@Repeatable`**      | 애노테이션을 반복해서 적용할 수 있게 합니다.(JDK1.8)         |

굵게 처리된 부분은 메타 애노테이션입니다.

## 애노테이션 정의하는 방법

### 기본형

```java
@interface 애너테이션명 {
  Type 요소이름();
  ...
}
```

새로운 애노테이션을 정의하는 방법은 위와 같습니다. 기본적으로 인터페이스 정의와 동일하고 `@` 기호를 붙이는 부분만 다릅니다.

### 애노테이션의 요소

애노테이션의 요소는 메서드 형태로 선언합니다.

요소는 기본형, String, 배열, Enum, 다른 애노테이션, 클래스들이 올 수 있습니다.

반환값이 있고, 매개변수가 없는 추상 메서드의 형태로 작성하면 됩니다. 매개변수는 받을 수 없습니다.

요소의 이름도 같이 적어주기 때문에 순서가 상관없습니다. (개인적으로 이 부분은 클래스 생성자에 들어오면 좋겠습니다.)

기본값을 `Type 속성명() default <기본값>` 형태로 지정할 수 있으며, 애노테이션을 사용할 때, 값이 지정되지 않은 경우 기본값이 사용됩니다.

애노테이션 요소가 하나뿐이고 이름이 `value`인 경우 애노테이션을 적용할 때, `value`를 생략하고 값만 적어도 됩니다.

배열타입 요소는 `{}` 를 사용해서 여러 개의 값을 전달해주면 됩니다.

애노테이션에는 예외를 선언할 수 없고, 제네릭 사용은 불가능합니다.

## @Retention

`@Retention`은 애노테이션이 유지되는 기간을 지정하는데 사용합니다. 애노테이션을 유지하는 기간을 설정하는 정책의 종류는 다음과 같습니다.

| 유지 정책 | 의미                                                         |
| --------- | ------------------------------------------------------------ |
| SOURCE    | 소스 파일에만 존재하고 클래스 파일에는 존재하지 않습니다.    |
| CLASS     | 클래스 파일에만 존재하고, 실행시에는 사용 불가 합니다. 기본 값입니다. |
| RUNTIME   | 클래스 파일에 존재하고, 실행 시점에도 존재합니다.            |

SOURCE 유지정책은 사실 컴파일러를 직접 작성하는 것이 아닌이상 우리가 사용할 일은 없습니다.

보통 `@Override`, `@SuppressWarnings` 같은 컴파일 시점에 컴파일러에 전달하는 정보의 경우에 사용하는 유지정책입니다.

우리가 흔히 사용하는 롬복의 정책이 바로 SOURCE 였습니다.

```java
@Target({ElementType.FIELD, ElementType.TYPE})
@Retention(RetentionPolicy.SOURCE)
public @interface Getter {
  ...
}
```

유지 정책을 RUNTIME으로 한다면 우리의 애플리케이션이 실행 중일 때, 리플렉션을 이용해서 클래스 파일에 저장된 애노테이션의 정보를 읽어서 처리해줄 수 있습니다.

우리가 자주 사용하는 JUnit의 Test 애노테이션의 정책이 바로 RUNTIME 입니다.

```java
@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@API(status = STABLE, since = "5.0")
@Testable
public @interface Test {
}
```

CLASS는 기본 값이지만 잘 사용되지 않는데, 그 이유는 클래스파일엔 존재하지만 런타임에는 애노테이션 정보를 읽어올 수 없기 때문입니다.

## @Target

`@Target`은 애노테이션이 적용가능한 대상을 지정하는데 사용합니다.

적용가능한 대상은 다음과 같습니다.

| 대상 타입       | 의미                            |
| --------------- | ------------------------------- |
| ANNOTATION_TYPE | 애너테이션                      |
| CONSTRUCTOR     | 생성자                          |
| FIELD           | 필드(멤버변수, enum 상수)       |
| LOCAL_VARIABLE  | 지역변수                        |
| METHOD          | 메서드                          |
| PACKAGE         | 패키지                          |
| PARAMETER       | 매개변수                        |
| TYPE            | 타입(클래스, 인터페이스, enum)  |
| TYPE_PRARMETER  | 타입 매개변수(JDK1.8)           |
| TYPE_USE        | 타입이 사용되는 모든 곳(JDK1.8) |

````java
@Target({FIELD, TYPE, TYPE_USE})
public @interface MyAnnotation {
  
}
````

위와 같은 식으로 정의해줄 수 있습니다.

## @Documented

## 애노테이션 프로세서

## 참고자료

[자바의 정석 3/e](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788994492032&orderClick=LEa&Kc=)
