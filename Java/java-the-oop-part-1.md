# Java의 정석 객체지향 프로그래밍 1 내용 정리

## 객체지향 기본

- 객체지향이론의 기본 개념: '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.'
  - 실제 객체지향이론의 발단은 모의실험(simulation)에서 왔다. 그러니 현실 세계와 완전히 똑같은 복제본이라기 보다는 유사한 가상 세계를 구현하는 것이라고 보는 것이 더 좋겠다. (이렇게 이해하면 객체지향 프로그래밍을 할 때, 걸림돌이 되기 쉽기 때문이다.)
  - 실제 사물의 속성과 기능을 분석해서 데이터와 함수로 정의해서 실제 세계를 모방하는 것이다.
- 이 이론은 현재에 이르기까지 상속, 추상화, 캡슐화 개념을 바탕으로 발전했다.
  - 자바 이전에도 많은 객체지향 언어들이 발표되었지만, Java가 인터넷의 발전과 함께 크게 유행해서 현재의 입지를 차지하고 있다.
- 객체지향 언어는 '절차적(procedural)' 언어와 대비되곤 한다. 절차지향이 아니다.
  - 코드간에 관계를 맺어줄 수 있게 되었다.
    - 코드의 재사용성이 높다. (기존 코드를 쉽게 재사용할 수 있다.)
    - 코드의 관리가 용이하다. (관게를 통해 이해할 수 있다.)
  - 신뢰성이 높은 프로그래밍을 가능하게 한다. (코드 중복으로 인한 오동작을 사전에 막을 수 있다.)
  - 이를 요약하면 '코드의 재사용성이 높고, 유지보수하기 용이하다.'
    - 상속, 다형성, 캡슐화 등의 개념을 이것과 연결시켜서 학습해야 한다. (+ 중복 제거)
- 초보자가 처음 부터 객체지향적으로 프로그래밍하기는 어렵다. 먼저 동작하는 프로그램을 만들고, 이를 어떻게 객체지향적으로 만들 수 있을지 고민하여 개선하는 것이 그 다음이다.
- 클래스란
  - 객체를 정의해놓은 것, 객체의 설계도 또는 틀, 청사진
  - 프로그래밍적으로는 데이터와 함수를 결합한 것이다. 변수와 함수를 유기적으로 연결해서 작업을 좀 더 사람이 이해하기 쉽게 한 것이다.
- 객체란
  - 유형적인 것 뿐만 아니라, 무형적인 것도 포함하는 실재하는 무엇
  - 클래스의 정의대로 메모리에 생성된 것
- 따라서 우리가 실제 필요한 것은 객체이지 클래스가 아님. 대신 클래스를 잘 만들어야 객체를 만들기가 수월해짐.
- 클래스로 부터 객체를 만드는 것을 클래스의 인스턴스화라고 하며, 클래스로 부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
  - 객체는 보다 포괄적인 의미이고, 인스턴스는 좀 더 구체적인 의미라고 볼 수 있다.
- 객체는 속성과 기능으로 이루어져 있으며, 보통 멤버 변수, 메서드로 표현한다.
- 보통 객체는 클래스 타입으로 정의된 참조변수를 선언하고 거기에 인스턴스를 생성해서 접근할 수 있도록 한다.  
  간단히 말해서 아래와 같은 형식으로 생성한다. (물론 `Class`는 예약어여서 동작하진 않는다.)

  ```java
  Class variable = new Class();
  ```

- 해당 클래스를 다루려면 해당 클래스의 참조변수가 필요하다. 이는 '인터페이스'에 대해서 공부하면 더 알 수 있다.
- 객체 배열은 사실 참조변수의 배열이다.

## 변수와 메서드

- 변수의 종류
  - 선언된 위치에 따라 변수의 종류가 결정된다.
  - 멤버 변수를 제외한 나머지 변수는 모두 지역변수다.
  - 멤버 변수에 `static`이 붙었으면 클래스 변수, 아니면 인스턴스 변수다.
  - 인스턴스 변수는 인스턴스 생성 시점에 만들어진다. 인스턴스 마다 독립적인 값을 가진다.
  - 클래스 변수는 모든 인스턴스들이 공유한다. 모두가 공통된 값을 가져야 하는 경우 선언할 수 있다.
  - 클래스 변수는 클래스로도 접근이 가능하다. 그리고 인스턴스로 접근할 수도 있지만, 헷갈리기 때문에 지양한다.
  - 클래스 변수는 클래스가 메모리 영역에 로딩되는 시점에 생성된다. `public`을 붙이면 전역 변수의 성격을 갖는다. 자바엔 전역변수가 없지만 전역변수처럼 쓸 수 있다는 의미다.
  - 지역변수는 해당 블록 내에서만 사용가능하며, 블록을 벗어나면 소멸되어 사용할 수 없게 된다.
- 메서드
  - 메서드는 특정 작업을 수행하는 일련의 문장을 하나로 묶은 것
  - 메서드가 어떤 과정을 거쳐서 결과를 만들어내는지 전혀 몰라도 된다. '인터페이스'와 관계있다.
  - 메서드를 사용하는 이유
    - 높은 재사용성
    - 중복된 코드의 제거
    - 프로그램의 구조화(작업 단위로 나눠서 프로그램의 구조를 단순화 시킨다.)
  - 선언부와 구현부
    - 선언부는 보통 메서드 시그니처라고도 한다.
      - 메서드의 이름, 매개변수, 반환 타입을 가지고 어떤 값을 필요로 하고, 어떤 값을 반환하는지 알려주는 역할이다.
      - 후에 변경사항이 발생하지 않도록 신중히 작성한다. (호출되는 부분까지 전부 변경해야하기 때문이다.) => 리팩토링 도구를 활용하는 방법도 있다.
      - 매개변수는 필요한 값들을 입력받기 위해 필요한 것이다. 값을 입력받을 필요가 없다면 입력하지 않아도 된다.
      - 메서드의 이름은 동사로 짓는게 일반적이다. 변수와 마찬가지로 의미있는 이름을 사용한다.
    - 구현부는 메서드를 호출했을 때, 사용되는 문장들을 작성한다.
      - 리턴타입이 `void`가 아닌경우 `return`문이 반드시 있어야 한다. 그리고 return 되는 값은 리턴타입과 같은 타입이거나 자동 형변환 가능해야 한다.
      - 사실 `return`문은 필수다. `void` 타입은 컴파일러가 알아서 넣어준다.
      - 리턴 값은 단 하나만 허용된다.
  - 메서드의 호출
    - `메서드이름(인자1, 인자2);` 와 같은 식으로 호출할 수 있다.
    - 반환 값이 있다면 해당 타입 변수에 저장할 수 있다.
    - 메서드는 호출되면 호출된 메서드를 실행하고 다시 원래 실행하던 메서드로 돌아온다.
  - 매개변수의 유효성 검사도 필요하다.
    - 메서드를 작성하는 사람은 '호출하는 쪽에서 어떤 값을 넘겨줄지 모른다'고 가정하고 작성하는게 맞다. 가능한 모든 경우의 수에 대해서 고민하고, 특히 타입으로 넘어오는 경우 `null` 값임에 주의한다.

## JVM의 메모리 구조

이 부분이 왜 객체지향 파트에 있어서 어렵게 만드는지 모르겠다.

JVM의 메모리 영역은 다음과 같이 구분할 수 있다.

- 메서드 영역(method area)
  - 클래스 파일을 읽어서 클래스에 대한 정보를 저장한다.
  - 클래스 변수도 이 영역에 저장된다.
- 힙(heap)
  - 인스턴스가 생성되는 공간이다.
  - GC의 대상이다.
- 호출 스택(call stack)
  - 호출 스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
  - 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간결과 등을 저장하는데 사용된다.
  - 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다.
  - 스택이라는 것에서 유추할 수 있듯이 메서드는 실행된 순서대로 차곡차곡 쌓이고, 이것이 한계에 도달하면 스택오버플로우(StackOverflow)가 발생하게 된다.
  - 호출 스택을 조사하면 메서드 간의 호출관계와 현재 수행중인 메서드가 어느 것인지도 알 수 있게된다.
    - 호출 스택의 맨 위의 메서드가 현재 수행중인 메서드이고, 그 아래에 위치한 메서드가 해당 메서드를 호출한 메서드다.

- 기본형 매개변수와 참조형 매개변수
